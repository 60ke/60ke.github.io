[{"content":" 布隆过滤器实现 goleveldb源码阅读 etcd源码阅读 simpleraft实现 ","date":"2022-04-11T10:15:27+08:00","permalink":"https://60ke.github.io/posts/%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/","title":"任务计划"},{"content":"Go目前支持GDB,LLDB,Delve等调试工具.官方出了GDB调试教程但是官方更推荐Delve(⊙ˍ⊙)\nDelve文档 Delve官方文档\ngo语言高级编程之Delve调试 为避免失联,将中文文档摘抄\n3.9 Delve 调试器 目前 Go 语言支持 GDB、LLDB 和 Delve 几种调试器。其中 GDB 是最早支持的调试工\u0026gt;具，LLDB 是 macOS 系统推荐的标准调试工具。但是 GDB 和 LLDB 对 Go 语言的专有\u0026gt;特性都缺乏很大支持，而只有 Delve 是专门为 Go 语言设计开发的调试工具。而且 \u0026gt;Delve 本身也是采用 Go 语言开发，对 Windows 平台也提供了一样的支持。本节我们\u0026gt;基于 Delve 简单解释如何调试 Go 汇编程序。\n3.9.1 Delve 入门 首先根据官方的文档正确安装 Delve 调试器。我们会先构造一个简单的 Go 语言代码，\u0026gt;用于熟悉下 Delve 的简单用法。\n创建 main.go 文件，main 函数先通过循初始化一个切片，然后输出切片的内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( \u0026#34;fmt\u0026#34; ) func main() { nums := make([]int, 5) for i := 0; i \u0026lt;len(nums); i++ { nums[i] = i * i } fmt.Println(nums) } 命令行进入包所在目录，然后输入 dlv debug 命令进入调试：\n1 2 3 $ dlv debug Type \u0026#39;help\u0026#39; for list of commands. (dlv) 输入 help 命令可以查看到 Delve 提供的调试命令列表：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 (dlv) help The following commands are available: args ------------------------ Print function arguments. break (alias: b) ------------ Sets a breakpoint. breakpoints (alias: bp) ----- Print out info for active \u0026gt;breakpoints. clear ----------------------- Deletes breakpoint. clearall -------------------- Deletes multiple breakpoints. condition (alias: cond) ----- Set breakpoint condition. config ---------------------- Changes configuration parameters. continue (alias: c) --------- Run until breakpoint or program \u0026gt;termination. disassemble (alias: disass) - Disassembler. down ------------------------ Move the current frame down. exit (alias: quit | q) ------ Exit the debugger. frame ----------------------- Set the current frame, or \u0026gt;execute command... funcs ----------------------- Print list of functions. goroutine ------------------- Shows or changes current \u0026gt;goroutine goroutines ------------------ List program goroutines. help (alias: h) ------------- Prints the help message. list (alias: ls | l) -------- Show source code. locals ---------------------- Print local variables. next (alias: n) ------------- Step over to next source line. on -------------------------- Executes a command when a \u0026gt;breakpoint is hit. print (alias: p) ------------ Evaluate an expression. regs ------------------------ Print contents of CPU registers. restart (alias: r) ---------- Restart process. set ------------------------- Changes the value of a variable. source ---------------------- Executes a file containing a \u0026gt;list of delve... sources --------------------- Print list of source files. stack (alias: bt) ----------- Print stack trace. step (alias: s) ------------- Single step through program. step-instruction (alias: si) Single step a single cpu \u0026gt;instruction. stepout --------------------- Step out of the current function. thread (alias: tr) ---------- Switch to the specified thread. threads --------------------- Print out info for every traced \u0026gt;thread. trace (alias: t) ------------ Set tracepoint. types ----------------------- Print list of types up -------------------------- Move the current frame up. vars ------------------------ Print package variables. whatis ---------------------- Prints type of an expression. Type help followed by a command for full documentation. (dlv) 每个 Go 程序的入口是 main.main 函数，我们可以用 break 在此设置一个断点：\n1 2 (dlv) break main.main Breakpoint 1 set at 0x10ae9b8 for main.main() ./main.go:7 然后通过 breakpoints 查看已经设置的所有断点：\n1 2 3 4 5 (dlv) breakpoints Breakpoint unrecovered-panic at 0x102a380 for runtime.startpanic() /usr/local/go/src/runtime/panic.go:588 (0) print runtime.curg._panic.arg Breakpoint 1 at 0x10ae9b8 for main.main() ./main.go:7 (0) 我们发现除了我们自己设置的 main.main 函数断点外，Delve 内部已经为 panic 异\u0026gt;常函数设置了一个断点。\n通过 vars 命令可以查看全部包级的变量。因为最终的目标程序可能含有大量的全局变\u0026gt;量，我们可以通过一个正则参数选择想查看的全局变量：\n1 2 3 4 5 (dlv) vars main main.initdone· = 2 runtime.main_init_done = chan bool 0/0 runtime.mainStarted = true (dlv) 然后就可以通过 continue 命令让程序运行到下一个断点处：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 (dlv) continue \u0026gt; main.main() ./main.go:7 (hits goroutine(1):1 total:1) (PC: \u0026gt;0x10ae9b8) 2: 3: import ( 4: \u0026#34;fmt\u0026#34; 5: ) 6: =\u0026gt; 7: func main() { 8: nums := make([]int, 5) 9: for i := 0; i \u0026lt;len(nums); i++ { 10: nums[i] = i * i 11: } 12: fmt.Println(nums) (dlv) 输入 next 命令单步执行进入 main 函数内部：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 (dlv) next \u0026gt; main.main() ./main.go:8 (PC: 0x10ae9cf) 3: import ( 4: \u0026#34;fmt\u0026#34; 5: ) 6: 7: func main() { =\u0026gt; 8: nums := make([]int, 5) 9: for i := 0; i \u0026lt;len(nums); i++ { 10: nums[i] = i * i 11: } 12: fmt.Println(nums) 13: } (dlv) 进入函数之后可以通过 args 和 locals 命令查看函数的参数和局部变量：\n1 2 3 4 (dlv) args (no args) (dlv) locals nums = []int len: 842350763880, cap: 17491881, nil 因为 main 函数没有参数，因此 args 命令没有任何输出。而 locals 命令则输出了局\u0026gt;部变量 nums 切片的值：此时切片还未完成初始化，切片的底层指针为 nil，长度和容量\u0026gt;都是一个随机数值。\n再次输入 next 命令单步执行后就可以查看到 nums 切片初始化之后的结果了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 (dlv) next \u0026gt; main.main() ./main.go:9 (PC: 0x10aea12) 4: \u0026#34;fmt\u0026#34; 5: ) 6: 7: func main() { 8: nums := make([]int, 5) =\u0026gt; 9: for i := 0; i \u0026lt;len(nums); i++ { 10: nums[i] = i * i 11: } 12: fmt.Println(nums) 13: } (dlv) locals nums = []int len: 5, cap: 5, [...] i = 17601536 (dlv) 此时因为调试器已经到了 for 语句行，因此局部变量出现了还未初始化的循环迭代变量 \u0026gt;i。\n下面我们通过组合使用 break 和 condition 命令，在循环内部设置一个条件断点，当\u0026gt;循环变量 i 等于 3 时断点生效：\n1 2 3 4 (dlv) break main.go:10 Breakpoint 2 set at 0x10aea33 for main.main() ./main.go:10 (dlv) condition 2 i==3 (dlv) 然后通过 continue 执行到刚设置的条件断点，并且输出局部变量：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 (dlv) continue \u0026gt; main.main() ./main.go:10 (hits goroutine(1):1 total:1) (PC: \u0026gt;0x10aea33) 5: ) 6: 7: func main() { 8: nums := make([]int, 5) 9: for i := 0; i \u0026lt;len(nums); i++ { =\u0026gt; 10: nums[i] = i * i 11: } 12: fmt.Println(nums) 13: } (dlv) locals nums = []int len: 5, cap: 5, [...] i = 3 (dlv) print nums []int len: 5, cap: 5, [0,1,4,0,0] (dlv) 我们发现当循环变量 i 等于 3 时，nums 切片的前 3 个元素已经正确初始化。\n我们还可以通过 stack 查看当前执行函数的栈帧信息：\n1 2 3 4 5 6 7 8 (dlv) stack 0 0x00000000010aea33 in main.main at ./main.go:10 1 0x000000000102bd60 in runtime.main at /usr/local/go/src/runtime/proc.go:198 2 0x0000000001053bd1 in runtime.goexit at /usr/local/go/src/runtime/asm_amd64.s:2361 (dlv) 或者通过 goroutine 和 goroutines 命令查看当前 Goroutine 相关的信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 (dlv) goroutine Thread 101686 at ./main.go:10 Goroutine 1: Runtime: ./main.go:10 main.main (0x10aea33) User: ./main.go:10 main.main (0x10aea33) Go: /usr/local/go/src/runtime/asm_amd64.s:258 runtime.rt0_go \u0026gt;(0x1051643) Start: /usr/local/go/src/runtime/proc.go:109 runtime.main \u0026gt;(0x102bb90) (dlv) goroutines [4 goroutines] * Goroutine 1 - User: ./main.go:10 main.main (0x10aea33) (thread \u0026gt;101686) Goroutine 2 - User: /usr/local/go/src/runtime/proc.go:292 \\ runtime.gopark (0x102c189) Goroutine 3 - User: /usr/local/go/src/runtime/proc.go:292 \\ runtime.gopark (0x102c189) Goroutine 4 - User: /usr/local/go/src/runtime/proc.go:292 \\ runtime.gopark (0x102c189) (dlv) 最后完成调试工作后输入 quit 命令退出调试器。至此我们已经掌握了 Delve 调试器器\u0026gt;的简单用法。\n3.9.2 调试汇编程序 用 Delve 调试 Go 汇编程序的过程比调试 Go 语言程序更加简单。调试汇编程序时，我\u0026gt;们需要时刻关注寄存器的状态，如果涉及函数调用或局部变量或参数还需要重点关注栈寄存\u0026gt;器 SP 的状态。\n为了编译演示，我们重新实现一个更简单的 main 函数：\n1 2 3 4 5 package main func main() { asmSayHello() } func asmSayHello() 在 main 函数中调用汇编语言实现的 asmSayHello 函数输出一个字符串。\nasmSayHello 函数在 main_amd64.s 文件中实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026#34;textflag.h\u0026#34; #include \u0026#34;funcdata.h\u0026#34; // \u0026#34;Hello World!\\n\u0026#34; DATA text\u0026lt;\u0026gt;+0(SB)/8,$\u0026#34;Hello Wo\u0026#34; DATA text\u0026lt;\u0026gt;+8(SB)/8,$\u0026#34;rld!\\n\u0026#34; GLOBL text\u0026lt;\u0026gt;(SB),NOPTR,$16 // func asmSayHello() TEXT ·asmSayHello(SB), $16-0 NO_LOCAL_POINTERS MOVQ $text\u0026lt;\u0026gt;+0(SB), AX MOVQ AX, (SP) MOVQ $16, 8(SP) CALL runtime·printstring(SB) RET 参考前面的调试流程，在执行到 main 函数断点时，可以 disassemble 反汇编命令查\u0026gt;看 main 函数对应的汇编代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 (dlv) break main.main Breakpoint 1 set at 0x105011f for main.main() ./main.go:3 (dlv) continue \u0026gt; main.main() ./main.go:3 (hits goroutine(1):1 total:1) (PC: \u0026gt;0x105011f) 1: package main 2: =\u0026gt;3: func main() { asmSayHello() } 4: 5: func asmSayHello() (dlv) disassemble TEXT main.main(SB) /path/to/pkg/main.go main.go:3 0x1050110 65488b0c25a0080000 mov rcx, qword ptr g \u0026gt;[0x8a0] main.go:3 0x1050119 483b6110 cmp rsp, qword ptr [r \u0026gt;+0x10] main.go:3 0x105011d 761a jbe 0x1050139 =\u0026gt;main.go:3 0x105011f* 4883ec08 sub rsp, 0x8 main.go:3 0x1050123 48892c24 mov qword ptr [rsp], rbp main.go:3 0x1050127 488d2c24 lea rbp, ptr [rsp] main.go:3 0x105012b e880000000 call $main.asmSayHello main.go:3 0x1050130 488b2c24 mov rbp, qword ptr [rsp] main.go:3 0x1050134 4883c408 add rsp, 0x8 main.go:3 0x1050138 c3 ret main.go:3 0x1050139 e87288ffff call $runtime.\u0026gt;morestack_noctxt main.go:3 0x105013e ebd0 jmp $main.main (dlv) 虽然 main 函数内部只有一行函数调用语句，但是却生成了很多汇编指令。在函数的开头\u0026gt;通过比较 rsp 寄存器判断栈空间是否不足，如果不足则跳转到 0x1050139 地址调用 \u0026gt;runtime.morestack 函数进行栈扩容，然后跳回到 main 函数开始位置重新进行栈空\u0026gt;间测试。而在 asmSayHello 函数调用之前，先扩展 rsp 空间用于临时存储 rbp 寄存\u0026gt;器的状态，在函数返回后通过栈恢复 rbp 的值并回收临时栈空间。通过对比 Go 语言代\u0026gt;码和对应的汇编代码，我们可以加深对 Go 汇编语言的理解。\n从汇编语言角度深刻 Go 语言各种特性的工作机制对调试工作也是一个很大的帮助。如果\u0026gt;希望在汇编指令层面调试 Go 代码，Delve 还提供了一个 step-instruction 单步执\u0026gt;行汇编指令的命令。\n现在我们依然用 break 命令在 asmSayHello 函数设置断点，并且输入 continue 命\u0026gt;令让调试器执行到断点位置停下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 (dlv) break main.asmSayHello Breakpoint 2 set at 0x10501bf for main.asmSayHello() ./main_amd64.\u0026gt;s:10 (dlv) continue \u0026gt; main.asmSayHello() ./main_amd64.s:10 (hits goroutine(1):1 \u0026gt;total:1) (PC: 0x10501bf) 5: DATA text\u0026lt;\u0026gt;+0(SB)/8,$\u0026#34;Hello Wo\u0026#34; 6: DATA text\u0026lt;\u0026gt;+8(SB)/8,$\u0026#34;rld!\\n\u0026#34; 7: GLOBL text\u0026lt;\u0026gt;(SB),NOPTR,$16 8: 9: // func asmSayHello() =\u0026gt; 10: TEXT ·asmSayHello(SB), $16-0 11: NO_LOCAL_POINTERS 12: MOVQ $text\u0026lt;\u0026gt;+0(SB), AX 13: MOVQ AX, (SP) 14: MOVQ $16, 8(SP) 15: CALL runtime·printstring(SB) (dlv) 此时我们可以通过 regs 查看全部的寄存器状态：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 (dlv) regs rax = 0x0000000001050110 rbx = 0x0000000000000000 rcx = 0x000000c420000300 rdx = 0x0000000001070be0 rdi = 0x000000c42007c020 rsi = 0x0000000000000001 rbp = 0x000000c420049f78 rsp = 0x000000c420049f70 r8 = 0x7fffffffffffffff r9 = 0xffffffffffffffff r10 = 0x0000000000000100 r11 = 0x0000000000000286 r12 = 0x000000c41fffff7c r13 = 0x0000000000000000 r14 = 0x0000000000000178 r15 = 0x0000000000000004 rip = 0x00000000010501bf rflags = 0x0000000000000206 ... (dlv) 因为 AMD64 的各种寄存器非常多，项目的信息中刻意省略了非通用的寄存器。如果再单步\u0026gt;执行到 13 行时，可以发现 AX 寄存器值的变化。\n1 2 3 4 5 6 (dlv) regs rax = 0x00000000010a4060 rbx = 0x0000000000000000 rcx = 0x000000c420000300 ... (dlv) 因此我们可以推断汇编程序内部定义的 text\u0026lt;\u0026gt; 数据的地址为 \u0026gt;0x00000000010a4060。我们可以用过 print 命令来查看该内存内的数据：\n1 2 3 (dlv) print *(*[5]byte)(uintptr(0x00000000010a4060)) [5]uint8 [72,101,108,108,111] (dlv) 我们可以发现输出的 [5]uint8 [72,101,108,108,111] 刚好是对应 “Hello” 字\u0026gt;符串。通过类似的方法，我们可以通过查看 SP 对应的栈指针位置，然后查看栈中局部变\u0026gt;量的值。\n至此我们就掌握了 Go 汇编程序的简单调试技术。\nEBPF与DLV 最近在学习epbf时发现Delve支持ebpf参数.\n在Ubuntu 20.04.5 LTS系统下,使用root权限\n命令如下:\n/home/lsk/go/bin/dlv trace foo --ebpf\n如果不加ebpf参数则默认使用ptrace参数,关于trace的具体使用方法见:https://github.com/go-delve/delve/blob/master/Documentation/usage/dlv_trace.md\n","date":"2023-03-09T10:54:32+08:00","permalink":"https://60ke.github.io/posts/go%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/","title":"go代码调试"},{"content":"homebrew 安装 \u0026amp;\u0026amp; 启动 1 2 3 4 brew install mysql # 一般安装完后就默认启动了 brew services start mysql brew services info mysql 修改root密码 homebrew 安装完的mysql,默认是没有密码的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 mysql -uroot # 允许弱密码登录 SET GLOBAL validate_password.policy=LOW #SET GLOBAL validate_password.LENGTH = 4; #SET GLOBAL validate_password.policy = 0; #SET GLOBAL validate_password.mixed_case_count = 0; #SET GLOBAL validate_password.number_count = 0; #SET GLOBAL validate_password.special_char_count = 0; #SET GLOBAL validate_password.check_user_name = 0; ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;你的新密码\u0026#39; # 刷新 FLUSH PRIVILEGES; # 授权 GRANT ALL PRIVILEGES ON *.* TO \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; WITH GRANT OPTION; ","date":"2022-11-18T16:23:10+08:00","permalink":"https://60ke.github.io/posts/mysql8.0/","title":"Mysql8.0"},{"content":"华为基于TrustZone开发了IturstTEE,一开始是在手机上使用,后来华为出了鲲鹏的服务器,在服务器端也支持了: https://www.hikunpeng.com/zh/developer/boostkit/confidential-computing。公司现有有一套泰山服务器搭建好了TEE环境,现记录一下TEE使用过程中遇到的问题。\n环境部署 https://support.huawei.com/enterprise/zh/doc/EDOC1100231607/778dd7e\n证书申请 https://support.huawei.com/enterprise/zh/doc/EDOC1100231607/65204c54\nSDK开发 CA,TA交互流程: itrustee sdk在码云上进行了开源,项目test目录下有代码示例,以helloword为例: helloword项目直接编译CA,TA并将其放入对应目录(CA=\u0026gt;/vendor/bin/,TA=\u0026gt;/data/),运行发现返回open session failed(坑来了\u0026hellip;),使用tlogcat命令查看日志,发现无相关日志输出\u0026hellip; 一番踩坑后发现:下面的这段代码缺少context.ta_path = (uint8_t *)\u0026quot;*.sec\u0026quot;;,导致CA根本没有连接到TA,所以根本没有日志\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 operation.started = OPERATION_START_FLAG; operation.paramTypes = TEEC_PARAM_TYPES( TEEC_NONE, TEEC_NONE, TEEC_NONE, TEEC_NONE); result = TEEC_OpenSession( \u0026amp;context, \u0026amp;session, \u0026amp;g_demoTemplateUuid, TEEC_LOGIN_IDENTIFY, NULL, \u0026amp;operation, \u0026amp;origin); if (result != TEEC_SUCCESS) { printf(\u0026#34;teec open session failed\u0026#34;); goto cleanup_2; } 加入代码后可以正常运行了:\n1 2 /vendor/bin/teec_hello Succeed to load TA, TA\u0026#39;s version: demo_20200601. 其它要注意的:\nCA运行路径需是: /vendor/bin/app_name TA:加载CA的路径: 1 addcaller_ca_exec(CA_PATH, \u0026#34;root\u0026#34;) == TEE_SUCCESS ","date":"2022-11-10T11:05:53+08:00","permalink":"https://60ke.github.io/posts/itrustee/","title":"Itrustee"},{"content":" C C语言结构体语法: 1 2 3 struct Bit{ unsigned b : 1; }; \u0026quot;:\u0026quot; (colon) in C struct - what does it mean? \u0026lt;==\u0026gt; https://stackoverflow.com/questions/824295/what-does-c-struct-syntax-a-b-mean\n","date":"2022-11-09T11:55:43+08:00","permalink":"https://60ke.github.io/posts/stackoverflow/","title":"Stackoverflow"},{"content":" Python autoDocstring: VSCode Python Docstring Generator https://github.com/NilsJPWerner/autoDocstring.git\nGolang https://github.com/0x00b/vscode-go-comment\ngoland https://github.com/loveinsky100/goanno C/C++等 doxdocgen https://github.com/cschlosser/doxdocgen\n基于机器学习: 支持: JavaScript Python TypeScript Java C# PHP Go Ruby https://marketplace.visualstudio.com/items?itemName=AkvelonPrimary.autocomment\n","date":"2022-11-07T17:26:15+08:00","permalink":"https://60ke.github.io/posts/vscode%E8%87%AA%E5%8A%A8%E6%B3%A8%E9%87%8A/","title":"Vscode自动注释"},{"content":"创建dockerbridge docker network create --driver bridge couch\n创建三个couchdb节点 1 2 3 4 5 sudo docker run -e COUCHDB_USER=admin -e COUCHDB_PASSWORD=8lab -e NODENAME=couchdb1 -p 15984:5984 --net=couch --name couchdb1 -d couchdb sudo docker run -e COUCHDB_USER=admin -e COUCHDB_PASSWORD=8lab -e NODENAME=couchdb2 -p 25984:5984 --net=couch --name couchdb2 -d couchdb sudo docker run -e COUCHDB_USER=admin -e COUCHDB_PASSWORD=8lab -e NODENAME=couchdb3 -p 35984:5984 --net=couch --name couchdb3 -d couchdb 部署集群 1 2 3 4 5 6 7 8 9 10 curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; http://admin:8lab@127.0.0.1:15984/_cluster_setup -d \u0026#39;{\u0026#34;action\u0026#34;: \u0026#34;enable_cluster\u0026#34;, \u0026#34;bind_address\u0026#34;:\u0026#34;0.0.0.0\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;password\u0026#34;:\u0026#34;8lab\u0026#34;, \u0026#34;node_count\u0026#34;:\u0026#34;3\u0026#34;}\u0026#39; curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; http://admin:8lab@127.0.0.1:15984/_cluster_setup -d \u0026#39;{\u0026#34;action\u0026#34;: \u0026#34;enable_cluster\u0026#34;, \u0026#34;bind_address\u0026#34;:\u0026#34;0.0.0.0\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;password\u0026#34;:\u0026#34;8lab\u0026#34;, \u0026#34;port\u0026#34;: 25984, \u0026#34;node_count\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;remote_node\u0026#34;: \u0026#34;couchdb2\u0026#34;, \u0026#34;remote_current_user\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;remote_current_password\u0026#34;: \u0026#34;8lab\u0026#34; }\u0026#39; curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; http://admin:8lab@127.0.0.1:15984/_cluster_setup -d \u0026#39;{\u0026#34;action\u0026#34;: \u0026#34;add_node\u0026#34;, \u0026#34;host\u0026#34;:\u0026#34;couchdb2\u0026#34;, \u0026#34;port\u0026#34;: \u0026#34;5984\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;password\u0026#34;:\u0026#34;8lab\u0026#34;}\u0026#39; curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; http://admin:8lab@127.0.0.1:15984/_cluster_setup -d \u0026#39;{\u0026#34;action\u0026#34;: \u0026#34;enable_cluster\u0026#34;, \u0026#34;bind_address\u0026#34;:\u0026#34;0.0.0.0\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;password\u0026#34;:\u0026#34;8lab\u0026#34;, \u0026#34;port\u0026#34;: 35984, \u0026#34;node_count\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;remote_node\u0026#34;: \u0026#34;couchdb3\u0026#34;, \u0026#34;remote_current_user\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;remote_current_password\u0026#34;: \u0026#34;8lab\u0026#34; }\u0026#39; curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; http://admin:8lab@127.0.0.1:15984/_cluster_setup -d \u0026#39;{\u0026#34;action\u0026#34;: \u0026#34;add_node\u0026#34;, \u0026#34;host\u0026#34;:\u0026#34;couchdb3\u0026#34;, \u0026#34;port\u0026#34;: \u0026#34;5984\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;password\u0026#34;:\u0026#34;8lab\u0026#34;}\u0026#39; curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; http://admin:8lab@127.0.0.1:15984/_cluster_setup -d \u0026#39;{\u0026#34;action\u0026#34;: \u0026#34;finish_cluster\u0026#34;}\u0026#39; 验证集群部署结果 1 2 3 curl http://admin:8lab@localhost:15984/_membership {\u0026#34;all_nodes\u0026#34;:[\u0026#34;couchdb@couchdb1\u0026#34;],\u0026#34;cluster_nodes\u0026#34;:[\u0026#34;couchdb@couchdb1\u0026#34;,\u0026#34;couchdb@couchdb2\u0026#34;,\u0026#34;couchdb@couchdb3\u0026#34;]} ","date":"2022-11-07T17:25:01+08:00","permalink":"https://60ke.github.io/posts/couchdb%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/","title":"Couchdb集群搭建"},{"content":"交易执行: CreateProposalBlock -\u0026gt; internal/state/state.go:MakeBlock -\u0026gt; types/block.go:MakeBlock\ninternal/consensus/state.go:NewState -\u0026gt; defaultDecideProposal -\u0026gt; createProposalBlock -\u0026gt;\nrpc : tri_broadcast_tx_commit\nBroadcastTxSync -\u0026gt; env.Mempool.CheckTx\ninternal/rpc/core/mempool.go:BroadcastTxCommit -\u0026gt; internal/rpc/core/tx.go:\n","date":"2022-11-04T14:14:43+08:00","permalink":"https://60ke.github.io/posts/tendermint%E4%BA%A4%E6%98%93%E6%89%A7%E8%A1%8C/","title":"Tendermint交易执行"},{"content":" 通过jsDelivr引用资源 使用方法：https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径 ","date":"2022-11-02T15:21:23+08:00","permalink":"https://60ke.github.io/posts/cdn%E5%8A%A0%E9%80%9F/","title":"Cdn加速"},{"content":"压缩 安装couchdb 登录web页面并查看数据库: http://10.182.1.77:5984/_utils/#/_all_dbs 压缩数据库,以_replicator为例,执行curl 1 curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; http://admin:8lab@127.0.0.1:5984/_replicator/_compact 刷新web页面查看数据库大小已经变小 备份 1 .couchdb默认配置即为4分片2备份:https://docs.couchdb.org/en/3.2.2-docs/cluster/sharding.html#shards-and-replicas 2.同时可以创建实时备份的任务\n进入web(http://10.182.1.77:5984/_utils/#/replication/_create)创建备份任务 选择continuous持续性备份(如果考虑到安全性可以选择远程备份)\n执行后就能看到持续进行的状态了 ","date":"2022-11-02T11:57:38+08:00","permalink":"https://60ke.github.io/posts/couchdb%E5%8E%8B%E7%BC%A9%E6%B5%8B%E8%AF%95/","title":"Couchdb压缩备份方案"},{"content":" 使用指定位置私钥 修改 ~/.ssh/config 1 2 3 4 5 Host github.com HostName github.com User git IdentityFile /home/lsk/.ssh/id_ed25519 IdentitiesOnly yes or you can try this:\nGIT_SSH_COMMAND=\u0026ldquo;ssh -i ~/.ssh/id_ed25519\u0026rdquo; git clone git@github.com:trias-lab/tmware.git\n同步最新代码,不覆盖本地修改 1、先将本地代码放到暂存区\n​​git stash​​\n2、将远程github（码云等）上面的代码拉取下来\n​​git pull​​\n3、将第一步暂存区的代码放回本地\n​​git stash pop​​\n","date":"2022-11-01T16:48:13+08:00","permalink":"https://60ke.github.io/posts/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E7%A7%81%E9%92%A5/","title":"Git常用笔记"},{"content":"docker磁盘占用空间过大,将其移到单独的新磁盘上:\n使用fdisk -l确定磁盘路径为/dev/sda 使用fdisk /dev/sda为磁盘分区 由于磁盘之前有个gpt已经存在一个分区了,故新分区被分配在了/dev/sda2路径下,需要使用fdisk -l确认 使用mkfs.ext4 /dev/sda2格式化/dev/sda2 使用mount /dev/sda2 /data挂载分区到/data目录下 如/data不存在需先创建 使用docker stop $(docker ps -a -q)停止当前的所有docker进程 使用mv /var/lib/docker /data/docker转移现有的docker数据 使用软连接ln -s /data/docker /var/lib/docker Reference: https://blog.csdn.net/duan19920101/article/details/104823301\n","date":"2022-11-01T16:20:18+08:00","permalink":"https://60ke.github.io/posts/docker%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE%E4%BF%AE%E6%94%B9/","title":"Docker存储位置修改"},{"content":"init ./geth --datadir data init genesis.json\n文件依赖： genesis.json 启动 1 ./geth --config config.toml --datadir ./data --networkid 820014 --rpc --rpcapi eth,net,web3,miner,txpool --rpcaddr 0.0.0.0 --rpcport 9545 --port 3060 config.toml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 [Eth] #DiscoveryURLs = [] NoPruning = false NoPrefetch = false LightPeers = 100 UltraLightFraction = 75 EnablePreimageRecording = false EWASMInterpreter = \u0026#34;\u0026#34; EVMInterpreter = \u0026#34;\u0026#34; [Eth.Miner] GasFloor = 30000000 GasCeil = 40000000 GasPrice = 1000000000 Recommit = 10000000000 Noverify = false [Eth.Ethash] CacheDir = \u0026#34;\u0026#34; CachesInMem = 0 CachesOnDisk = 0 CachesLockMmap = false DatasetDir = \u0026#34;\u0026#34; DatasetsInMem = 0 DatasetsOnDisk = 0 DatasetsLockMmap = false PowMode = 0 [Eth.TxPool] Locals = [] NoLocals = true Journal = \u0026#34;transactions.rlp\u0026#34; Rejournal = 3600000000000 PriceLimit = 1000000000 PriceBump = 10 AccountSlots = 16 GlobalSlots = 4096 AccountQueue = 64 GlobalQueue = 1024 Lifetime = 10800000000000 [Eth.GPO] Blocks = 20 Percentile = 60 #[Shh] #MaxMessageSize = 1048576 #RestrictConnectionBetweenLightClients = true [Node] DataDir = \u0026#34;~/data/node1\u0026#34; #omitempty = \u0026#34;\u0026#34; InsecureUnlockAllowed = true NoUSB = true IPCPath = \u0026#34;geth.ipc\u0026#34; HTTPHost = \u0026#34;0.0.0.0\u0026#34; HTTPPort = 8545 HTTPVirtualHosts = [\u0026#34;*\u0026#34;] HTTPModules = [\u0026#34;debug\u0026#34;,\u0026#34;eth\u0026#34;, \u0026#34;net\u0026#34;, \u0026#34;web3\u0026#34;, \u0026#34;txpool\u0026#34;, \u0026#34;parlia\u0026#34;] WSPort = 8576 WSModules = [\u0026#34;net\u0026#34;, \u0026#34;web3\u0026#34;, \u0026#34;eth\u0026#34;] #GraphQLPort = 8577 GraphQLVirtualHosts = [\u0026#34;*\u0026#34;] [Node.P2P] MaxPeers = 50 NoDiscovery = false StaticNodes = [] BootstrapNodes = [] TrustedNodes = [] ListenAddr = \u0026#34;127.0.0.1:30303\u0026#34; EnableMsgEvents = false [Node.HTTPTimeouts] ReadTimeout = 30000000000 WriteTimeout = 30000000000 IdleTimeout = 120000000000 [Node.LogConfig] FileRoot = \u0026#34;\u0026#34; FilePath = \u0026#34;log/bsc.log\u0026#34; MaxBytesSize = 10485760 Level = \u0026#34;info\u0026#34; 调试 1 dlv debug . -- --config /Users/k/bsc_test/config.toml --datadir /Users/k/bsc_test/data --networkid 820014 --rpc --rpcapi eth,net,web3,miner,txpool --rpcaddr 0.0.0.0 --rpcport 8545 --port 30303 调试工具 (dlv)[https://chai2010.cn/advanced-go-programming-book/ch3-asm/ch3-09-debug.html] (gdb)[https://go.dev/doc/gdb] ","date":"2022-10-31T16:50:41+08:00","permalink":"https://60ke.github.io/posts/bsc_debug/","title":"Bsc_debug"},{"content":" bsc编译 hidapi错误 1 2 3 4 # github.com/karalabe/usb ../../vendor/github.com/karalabe/usb/hid_enabled.go:22:10: fatal error: ./hidapi/hidapi/hidapi.h: No such file or directory 22 | #include \u0026#34;./hidapi/hidapi/hidapi.h\u0026#34; compilation terminated. 解决办法:\n1 2 rm -fr usb git clone https://github.com/karalabe/usb ","date":"2022-10-31T15:29:19+08:00","permalink":"https://60ke.github.io/posts/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/","title":"工作笔记"},{"content":"今天公司台式机断电重启后,在登录之前黑屏进不去了.搞了好一会解决了,记录一下过程:\n使用e按键进入grub 将quiet splash替换为nomodset nomodset The newest kernels have moved the video mode setting into the kernel. So all the programming of the hardware specific clock rates and registers on the video card happen in the kernel rather than in the X driver when the X server starts.. This makes it possible to have high resolution nice looking splash (boot) screens and flicker free transitions from boot splash to login screen. Unfortunately, on some cards this doesn\u0026rsquo;t work properly and you end up with a black screen. Adding the nomodeset parameter instructs the kernel to not load video drivers and use BIOS modes instead until X is loaded. quiet splash The splash (which eventually ends up in your /boot/grub/grub.cfg ) causes the splash screen to be shown. At the same time you want the boot process to be quiet, as otherwise all kinds of messages would disrupt that splash screen.\nAlthough specified in GRUB these are kernel parameters influencing the loading of the kernel or its modules, not something that changes GRUB behaviour. The significant part from GRUB_CMDLINE_LINUX_DEFAULT is CMDLINE_LINUX\n3.ctrl alt F1(open TTY)或是alt F2开启新的终端就能以命令行的方式登录了.\n运行journalctl -xe与systemctl status NetworkManager.service得知错误的原因是因为磁盘满了.清除磁盘空间重启可以正常进入了\n系统启动后NetworkManager.service无法启动(显示一直重启),进一步排查发现/etc/NetworkManager/NetworkManager.conf配置格式不对(不知道什么时候被更改了) 将\n1 2 3 4 5 6 7 8 main] plugins=ifupdown,keyfile [ifupdown] managed=true [device] wifi.scan-rand-mac-address=n 改为\n1 2 3 4 5 6 7 8 [main] plugins=ifupdown,keyfile [ifupdown] managed=true [device] wifi.scan-rand-mac-address=n ","date":"2022-10-31T13:59:35+08:00","permalink":"https://60ke.github.io/posts/ubuntu%E9%BB%91%E5%B1%8F%E6%97%A0%E6%B3%95%E7%99%BB%E5%BD%95/","title":"Ubuntu黑屏无法登录"},{"content":"准备 GitHub personal access 部署的 Action 需要有对应仓库的权限，因此提前设置好 GitHub personal access（个人访问令牌）。生成教程可以看 GitHub 官方的帮助文档：创建用于命令行的个人访问令牌 选择账户设置的setting 选择Developer settings-\u0026gt;Personal access tokens-\u0026gt;Generate new token 3.生成新的token 设置token名GOACTION 授予repo权限 github项目trustnode_auto_validator 编写action的yml文件 编写.github/workflows/main.yml文件\n编写触发条件 项目目前有且只有一个main分支,设置action的触发条件为push到main分支后,对应yaml内容如下:\n1 2 3 4 5 # 触发条件：在 push 到 main 分支后 on: push: branches: - main 设置jobs和运行环境 设置jobs名字为:buildAndDeploy(这个可以根据自己的喜好起),通过runs-on设置运行环境为:ubuntu-latest\n1 2 3 jobs: buildAndDeploy: runs-on: ubuntu-latest 设置go交叉编译 针对 arm64、amd64 和 Linux、Darwin的组合进行交叉编译：\n使用checkout@v3获取代码 setup-go@v3 设置 golang 环境，并在 with 字句中指定了go版本需大于1.16.0 make 这里使用了 Matrix 定义的变量，循环构建每个组合； 对应yaml内容如下: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 交叉构建,多平台交叉编译 strategy: matrix: include: - goarch: amd64 goos: linux - goarch: amd64 goos: darwin - goarch: arm64 goos: linux - goarch: arm64 goos: darwin # 使用checkout steps: - uses: actions/checkout@v3 - name: Set up Go uses: actions/setup-go@v3 with: go-version: \u0026#39;\u0026gt;=1.16.0\u0026#39; - run: go version - name: make run: make env: GOOS: ${{ matrix.goos }} GOARCH: ${{ matrix.goarch }} 自动发布编译后的二进制 使用upload-release-asset进行二进制发布:\n1 2 3 4 5 6 7 8 9 10 11 12 13 - name: Packaging... run: tar czf nodeUpgrade-${{ matrix.goos }}-${{ matrix.goarch }}.tgz nodeUpgrade - name: Uploading assets... # if: ${{ !env.ACT }} id: upload-release-asset uses: actions/upload-release-asset@v1 env: GITHUB_TOKEN: ${{ secrets.GOACTION }} with: upload_url: ${{ github.event.release.upload_url }} asset_path: ./nodeUpgrade-${{ matrix.goos }}-${{ matrix.goarch }}.tgz asset_name: nodeUpgrade-${{ matrix.goos }}-${{ matrix.goarch }}.tgz asset_content_type: application/gzip 完整的yaml文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 name: Publish Go Binary # 触发条件：在 push 到 main 分支后 on: push: branches: - main env: GITHUB_TOKEN: ${{ secrets.GOACTION }} jobs: buildAndDeploy: runs-on: ubuntu-latest env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # 交叉构建,多平台交叉编译 strategy: matrix: include: - goarch: amd64 goos: linux - goarch: amd64 goos: darwin - goarch: arm64 goos: linux - goarch: arm64 goos: darwin # 使用checkout steps: - uses: actions/checkout@v3 - name: Set up Go uses: actions/setup-go@v3 with: go-version: \u0026#39;\u0026gt;=1.16.0\u0026#39; - run: go version - name: make run: make env: GOOS: ${{ matrix.goos }} GOARCH: ${{ matrix.goarch }} - name: Packaging... run: tar czf nodeUpgrade-${{ matrix.goos }}-${{ matrix.goarch }}.tgz nodeUpgrade - name: Get version id: version run: echo \u0026#34;::set-output name=version::$(git rev-parse --short HEAD)\u0026#34; - name: Gets latest created release info uses: \u0026#34;marvinpinto/action-automatic-releases@latest\u0026#34; with: repo_token: \u0026#34;${{ secrets.GITHUB_TOKEN }}\u0026#34; automatic_release_tag: ${{ steps.version.outputs.version }} prerelease: true title: \u0026#34;Development Build\u0026#34; files: | ./nodeUpgrade-${{ matrix.goos }}-${{ matrix.goarch }}.tgz # - name: Uploading assets... # # if: ${{ !env.ACT }} # # id: upload-release-asset # uses: actions/upload-release-asset@v1 # env: # GITHUB_TOKEN: ${{ secrets.GOACTION }} # with: # upload_url: ${{ steps.latest_release_info.outputs.upload_url }} # asset_path: ./nodeUpgrade-${{ matrix.goos }}-${{ matrix.goarch }}.tgz # asset_name: nodeUpgrade-${{ matrix.goos }}-${{ matrix.goarch }}.tgz # asset_content_type: application/gzip Reference: https://cloud.tencent.com/developer/article/1884133\n","date":"2022-08-30T15:30:59+08:00","permalink":"https://60ke.github.io/posts/githubaction/","title":"Github使用Action自动编译发布go项目"},{"content":"BlockMaze隐私交易 定义 BlockMaze，一种基于 zk-SNARKs 的高效隐私保护账户模型区块链。与双余额模型一起，BlockMaze 通过隐藏账户余额、交易金额以及发送者和接收者之间的联系来实现强大的隐私保证。BlockMaze是基于 Libsnark 和 Go-Ethereum 实现的。\n实现原理及交易流程 一、实现原理 blockmaze隐私交易的实现为在账户下添加cmt(commitment)用于存储密文余额，发送交易时使用接受者的公钥加密且不指定接受者的地址，但是在链下告诉接受者该交易的hash，同时减去自己对应的密文余额。接受者通过交易hash获取对应的交易信息，同时通过私钥解密转账的金额，然后加上自己对应的密文余额。(相当于隐私交易的转账金额存到了隐私交易里面)。 二、交易流程 ![[20220714192452.jpg]] 1.节点A执行Mint操作，转化零知识余额到自己的账户中 2.节点B执行getPubKeyRLP()根据其账户地址获取其公钥，线下告诉节点A， 3.节点A执行Send操作进行转账，并更新自己的零知识余额，其中pubkey为接收方(节点B)的公钥,线下告诉节点B 交易SendTransaction的hash 4.节点B通过节点A产生的send交易的hash执行Deposit操作 5.节点A执行Redeem操作，转化明文余额到自己的账户中\nQuorum隐私交易 定义 隐私是指在相关参与者之间保持交易私密的能力。其他参与者无法访问交易内容。\n实现原理及交易流程 一、实现原理 quorum通过一个名为Tessera 的隐私交易管理器来管理隐私交易。发送者将原有的交易payload用key替代(key为Tessera对该payload加密生成的)，隐私交易的接收方通过Tessera获取key对应的原始交易payload。如果该交易为合约调用交易，非接收方的账户跳过该交易的执行，接收方则通过Tessera还原payload并调用虚拟机执行然后更新存储。同时为了避免因此带来的状态不一致，隐私交易和公共交易存储的树是用不同的树分开存储的。\n状态验证：块验证包括检查公共状态树的根以确定公共状态是否跨节点同步。它还包括检查全局交易哈希，这是一个区块中所有公共和私人交易的哈希。这意味着每个节点都可以验证它与其他节点具有相同的交易集。公共状态根和私有交易输入的同步（通过全局交易哈希）意味着参与节点之间私有状态的同步。进一步验证如果私有交易的私有状态变化在所有参与者中是相同的，可使eth_storageRoot 指定私有智能合约地址和区块高度。如果状态在所有参与节点之间同步，则它们返回相同的根哈希。\n限制: 隐私合约交易在与公共合约交易进行数据交互时，隐私合约交易智能读取公共存储的状态，而不能写入(一旦写入会造成隐私交易接收者和非接受者数据不一致的情况)\n二、交易流程 (1) 一般隐私交易 ![[Pasted image 20220722165506.png]]\n参与者 A 向其 GoQuorum 节点 A 发送私人交易。\nGoQuorum 将私有交易data值序列化为 JSON，并将其与参与者详细信息一起发送到 Tessera 节点 A。\nTessera 加密data并分发给交易参与者。\nTessera 将加密的哈希返回data给 GoQuorum 节点 A。GoQuorum 用data哈希替换私有交易值。GoQuorum 签署私人交易并将其设置v为37或38将交易标记为私人交易。\nGoQuorum 在整个网络中分发私人交易。\n所有节点都可以看到交易。只有交易参与者（参与者 A 和 B）才能从 Tessera 获取解密数据并执行交易。 (2) 隐私标记交易 ![[Pasted image 20220722165642.png]]\n参与者 A 向其 GoQuorum 节点 A 发送私人交易。\nGoQuorum 将私有交易data值序列化为 JSON，并将其与参与者详细信息一起发送到 Tessera 节点 A。\nTessera 加密data并分发给交易参与者。\nTessera 将加密的哈希返回data给 GoQuorum 节点 A。GoQuorum 创建一个公共 PMT，并将data字段设置为哈希。GoQuorum 签署 PMT。\nGoQuorum 在整个网络中分发 PMT。所有节点都可以看到 PMT。\nPMT 的处理方式与标准公共交易相同。由于 PMT 的to值是隐私预编译合约的地址，因此该合约被调用。\nGoQuorum 节点 B 和 C 使用 PMT 调用隐私预编译data。\nGoQuorum 尝试使用来自 PMT 的公开可用哈希从 Tessera 检索解密的私人交易。\n动作取决于节点是否是事务参与者：\n参与者：GoQuorumdata从 Tessera 获取隐私交易的解密信息，隐私预编译执行隐私交易。\n非参与者：没有找到隐私交易，所以隐私预编译立即返回。 (3) 有关零知识证明的隐私交易 https://github.com/ConsenSys/anonymous-zether 是在quorum基础上基于zether实现的零知识证明的隐私交易。\n结论 BlockMaze通过在原有的以太坊账户模型中添加一个用于存储隐私金额的密文字段，然后通过隐私交易对账户的密文余额进行操作，BlockMaze仅支持转账之间的金额隐私交易，不涉及有关智能合约的执行。BlockMaz零知识证明采用zk-snark。BlockMaze宣称的隐藏交易双方的对应关系是通过一次性构建多笔交易，这些交易存在多个发送方和接收方从而模糊发送者和接受者的对应关系。但其仅支持转账类型的隐私交易，不过其结构设计较为简单，但是其代码长期未更新，项目整体更像是一个demo，没见在实际中的应用，其方案可能存在许多隐藏问题。\nquorum也是基于账户模型开发的，而且支持所有类型的隐私交易(转账交易与合约交易)，其方案考虑的比较完善且代码更新活跃，文档完善，不过其结构设计相对BlockMaze更为复杂，但结构比较清晰。\n总的来说quorum能够实现更为完善的隐私交易，具备多种共识方案的切换(其链本身的特性)，同时其项目也在实际中广泛应用，能够提供更为完备的解决方案。\n","date":"2022-08-24T19:56:44+08:00","permalink":"https://60ke.github.io/posts/quorum%E9%9A%90%E7%A7%81%E4%BA%A4%E6%98%93%E7%9A%84%E7%BB%93%E6%9E%84%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%E5%8F%8A%E4%B8%8Eblockmaze%E7%9A%84%E6%AF%94%E8%BE%83/","title":"Quorum隐私交易的结构流程分析及与BlockMaze的比较"},{"content":"什么是共识机制 先说共识,多个独立的个体对事物产生一致的认识.在计算机科学中,分布式系统中的一个基本问题是在存在多个故障进程的情况下实现系统的整体可靠性。这通常需要协调过程以达成共识，或就计算过程中需要的某些数据值达成一致。协商一致的示例应用包括约定将哪些事务以何种顺序提交到数据库、状态机复制和原子广播。通常需要共识的现实世界应用包括云计算、时钟同步、PageRank、意见形成、智能电网、状态估计、无人机控制（以及多个机器人/代理）、负载平衡、区块链等。\n共识机制的思想均可在现实世界中找到对应的场景.认为总体可分为两类:\n无许可共识 一旦有结果出现正常情况下所有个体均认可结果.比如多劳多得,存款越多利息越多.区块链中常说的挖矿即PoW(Proof-of-Work)算法,可以理解为多劳多得,以太坊2.0使用的PoS(Proof-of-Stake)算法可以理解为存款越多利息越多.这些\u0026quot;规矩\u0026quot;是一开始大家都认同的,无需对每一次结果再次投票. 有许可共识 有许可共识即所有的个体对每一次预产生结果进行投票,该结果获得多数投票才能最终落地. 常用的有许可共识也可分为两类:拜占庭容错和非拜占庭容错. 拜占庭将军问题（Byzantine Generals Problem），是由莱斯利·兰波特在其同名论文[1]中提出的分布式对等网络通信容错问题。在分布式计算中，不同的计算机通过通讯交换信息达成共识而按照同一套协作策略行动。但有时候，系统中的成员计算机可能出错而发送错误的信息，用于传递信息的通讯网络也可能导致信息损坏，使得网络中不同的成员关于全体协作的策略得出不同结论[2]，从而破坏系统一致性[3]。拜占庭将军问题被认为是容错性问题中最难的问题类型之一。莱斯利·兰波特在其论文[1]中描述了如下问题：\n一组拜占庭将军分别各率领一支军队共同围困一座城市。为了简化问题，将各支军队的行动策略限定为进攻或撤离两种。因为部分军队进攻部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。因为各位将军分处城市不同方向，他们只能通过信使互相联系。在投票过程中每位将军都将自己投票给进攻还是撤退的信息通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以知道共同的投票结果而决定行动策略。\n系统的问题在于，可能将军中出现叛徒，他们不仅可能向较为糟糕的策略投票，还可能选择性地发送投票信息。假设有9位将军投票，其中1名叛徒。8名忠诚的将军中出现了4人投进攻，4人投撤离的情况。这时候叛徒可能故意给4名投进攻的将领送信表示投票进攻，而给4名投撤离的将领送信表示投撤离。这样一来在4名投进攻的将领看来，投票结果是5人投进攻，从而发起进攻；而在4名投撤离的将军看来则是5人投撤离。这样各支军队的一致协同就遭到了破坏。\n由于将军之间需要通过信使通讯，叛变将军可能通过伪造信件来以其他将军的身份发送假投票。而即使在保证所有将军忠诚的情况下，也不能排除信使被敌人截杀，甚至被敌人间谍替换等情况。因此很难通过保证人员可靠性及通讯可靠性来解决问题。\n假使那些忠诚（或是没有出错）的将军仍然能通过多数决定来决定他们的战略，便称达到了拜占庭容错。在此，票都会有一个默认值，若消息（票）没有被收到，则使用此默认值来投票。\n上述的故事映射到计算机系统里，将军便成了计算机，而信差就是通信系统。虽然上述的问题涉及了电子化的决策支持与信息安全，却没办法单纯的用密码学与数字签名来解决。因为电路错误仍可能影响整个加密过程，这不是密码学与数字签名算法在解决的问题。因此计算机就有可能将错误的结果提交去，亦可能导致错误的决策。\n1.非拜占庭容错算法,现有的解决方案为Paxos或类Paxos算法如Raft\n2.拜占庭容错则有pbft,ibft,hotstuff等\n需要特别注意的是,在计算机领域的共识,是针对同一套程序即预期有特定输出结果的结果进行共识.也就是说理论上在节点通讯正常,节点运行正常,未被干扰的情况下所有的节点计算的结果是一致的.以太坊的EVM虚拟机即为保证在输入结果一致的情况下,输出也是一致而实现的.\n无许可共识当前一般在币圈应用,本文不再讨论,下面仅针对有许可共识进行进一步研究.\n","date":"2022-04-20T16:25:36+08:00","permalink":"https://60ke.github.io/posts/%E6%B5%85%E8%B0%88%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE/","title":"浅谈共识协议"},{"content":"P2pHolePunching之为了搞懂p2p打洞,我买了台腾讯云 what\u0026rsquo;s p2p p2p是点对点(端对端)协议.当前我们经常用的网络服务比如抖音,淘宝,百度,等等的网络架构为C/S架构即客户端/服务端.是中心化的,而纯粹的p2p通信,我们的主机既扮演客户端角色又扮演服务器角色,不再需要类似腾讯,阿里等服务提供商,所以是去中心化的.\n","date":"2022-04-15T11:23:44+08:00","permalink":"https://60ke.github.io/posts/p2pholepunching/","title":"P2pHolePunching"},{"content":" 之前go在1.18 dev版本中支持了泛型,当时大致的看了一下,但是考虑到是dev版本可能功能并没有完全确定,所以并没有进行练习。今天更新到go1.18 darwin/arm64发现可以直接用泛型了,写篇文章记下笔记。\n泛型程序设计（generic programming）是程序设计语言的一种风格或范式。泛型允许程序员在强类型程序设计语言中编写代码时使用一些以后才指定的类型,在实例化时作为参数指明这些类型。各种程序设计语言和其编译器、运行环境对泛型的支持均不一样。Ada、Delphi、Eiffel、Java、C#、F#、Swift 和 Visual Basic .NET 称之为泛型（generics）；ML、Scala 和 Haskell 称之为参数多态（parametric polymorphism）；C++ 和 D称之为模板。具有广泛影响的1994年版的《Design Patterns》一书称之为参数化类型（parameterized type）。\n之前在使用RUST时经常用到泛型,泛型重要特征之一就是泛型约束(类型约束)。 通俗的讲,就是我们怎么用看起来像一种类型的表现方式来表示对多种数据类型的支持。笔者认为泛型是针对于强类型语言,提供一种类似弱类型语言的使用体验,泛型可以让开发者书写更少的代码片段,能够提升开发效率,但是并不能提升语言的执行效率,甚至会降低一部分执行效率(取决于泛型支持是在编译时的支持还是运行时的支持),这也是go迟迟没有支持泛型的原因。\n下面的python代码中实现了一个sum函数,对于参数a,bpython中我们是可以传递整数,浮点数,字符串甚至与数组等支持+预算的数据类型。\n1 2 def sum(a,b): return a+b go之前不支持泛型的版本,我们需要针对每一种类型都做一次函数实现以支撑不同类型的调用。\n先看go泛型的官方教程:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 package main import \u0026#34;fmt\u0026#34; type Number interface { int64 | float64 } func main() { // Initialize a map for the integer values ints := map[string]int64{ \u0026#34;first\u0026#34;: 34, \u0026#34;second\u0026#34;: 12, } // Initialize a map for the float values floats := map[string]float64{ \u0026#34;first\u0026#34;: 35.98, \u0026#34;second\u0026#34;: 26.99, } fmt.Printf(\u0026#34;Non-Generic Sums: %v and %v\\n\u0026#34;, SumInts(ints), SumFloats(floats)) fmt.Printf(\u0026#34;Generic Sums: %v and %v\\n\u0026#34;, SumIntsOrFloats[string, int64](ints), SumIntsOrFloats[string, float64](floats)) fmt.Printf(\u0026#34;Generic Sums, type parameters inferred: %v and %v\\n\u0026#34;, SumIntsOrFloats(ints), SumIntsOrFloats(floats)) fmt.Printf(\u0026#34;Generic Sums with Constraint: %v and %v\\n\u0026#34;, SumNumbers(ints), SumNumbers(floats)) } // SumInts adds together the values of m. func SumInts(m map[string]int64) int64 { var s int64 for _, v := range m { s += v } return s } // SumFloats adds together the values of m. func SumFloats(m map[string]float64) float64 { var s float64 for _, v := range m { s += v } return s } // SumIntsOrFloats sums the values of map m. It supports both floats and integers // as map values. func SumIntsOrFloats[K comparable, V int64 | float64](m map[K]V) V { var s V for _, v := range m { s += v } return s } // SumNumbers sums the values of map m. Its supports both integers // and floats as map values. func SumNumbers[K comparable, V Number](m map[K]V) V { var s V for _, v := range m { s += v } return s } 从上面的代码我们可以看到,go通过|运算符来实现类型约束,并且可以通过interface对其类型进行包装.官方示例为对map中的value进行求和.这里再实现一个类似前面提到的python sum函数的go泛型实现:\n1 2 3 4 5 6 7 8 type Number interface { int64 | float64 | int } func sum[V Number](a, b V) V { return a + b } ","date":"2022-03-29T10:23:34Z","permalink":"https://60ke.github.io/posts/go%E6%B3%9B%E5%9E%8B%E5%AE%9E%E8%B7%B5/","title":"go泛型实践"},{"content":"go汇编传送门:\n首先创建一个pkg.go文件,内容如下：\n1 2 package pkg var Id = 9527 用以下命令查看的Go语言程序对应的伪汇编代码：\n1 2 3 4 5 go tool compile -S pkg.go # 或 go build -gcflags=-S pkg.go # -N关闭内联汇编 go build -gcflags=\u0026#34;-S -N\u0026#34; pkg.go 其中gcflags,为go compile flags。关于gcflags的使用帮助可以使用go help build查看。查看gcflags参数可用go help compile;运行命令我们可以看到下面的arm64汇编输出:\n1 2 3 4 5 6 7 8 9 10 11 12 13 # command-line-arguments go.cuinfo.producer.command-line-arguments SDWARFCUINFO dupok size=0 0x0000 2d 73 68 61 72 65 64 -shared go.cuinfo.packagename.command-line-arguments SDWARFCUINFO dupok size=0 0x0000 70 6b 67 pkg \u0026#34;\u0026#34;.Id SNOPTRDATA size=8 0x0000 37 25 00 00 00 00 00 00 7%...... go.info.command-line-arguments.Id SDWARFVAR dupok size=42 0x0000 08 63 6f 6d 6d 61 6e 64 2d 6c 69 6e 65 2d 61 72 .command-line-ar 0x0010 67 75 6d 65 6e 74 73 2e 49 64 00 09 03 00 00 00 guments.Id...... 0x0020 00 00 00 00 00 00 00 00 00 01 .......... rel 29+8 t=1 \u0026#34;\u0026#34;.Id+0 rel 37+4 t=31 go.info.int+0 PS: amd64汇编要简单很多：\n1 2 3 4 5 # command-line-arguments go.cuinfo.packagename.command-line-arguments SDWARFCUINFO dupok size=0 0x0000 70 6b 67 pkg \u0026#34;\u0026#34;.Id SNOPTRDATA size=8 0x0000 37 25 00 00 00 00 00 00 7%...... 逐段分析汇编： 1.\n1 2 go.cuinfo.producer.command-line-arguments SDWARFCUINFO dupok size=0 0x0000 2d 73 68 61 72 65 64 -shared go.cuinfo.来自(dwarf.go)[https://github.com/golang/go/blob/master/src/cmd/internal/dwarf/dwarf.go]代码中的定义：\n1 2 3 // CUInfoPrefix is the prefix for symbols containing information to // populate the DWARF compilation unit info entries. const CUInfoPrefix = \u0026#34;go.cuinfo.\u0026#34; dwraf全称debugging with attributed record formats。\ndwarf包的说明: Package dwarf provides access to DWARF debugging information loaded from executable files, as defined in the DWARF 2.0 Standard at http://dwarfstd.org/doc/dwarf-2.0.0.pdf\n(dwarf wiki)[https://en.wikipedia.org/wiki/DWARF] dwarf 相关资料(ibm)[https://developer.ibm.com/articles/au-dwarf-debug-format/] (Parsing Go Binary DWARF Info)[https://www.grant.pizza/blog/dwarf/] 关于dwraf的说明我们以后可以单独写一篇文章,这里大致了解其为一种广泛使用的标准化调试数据格式。 SDWARFCUINFO即为 section dwarf cuinfo,dupok定义在(textflag.h)[https://github.com/golang/go/blob/master/src/runtime/textflag.h]中,该文件定义了附加到各种函数和数据对象的标志。编译器、汇编器和链接器都必须就这些值达成一致。(待进一步说明) 0x0000 2d 73 68 61 72 65 64为\u0026quot;-shared\u0026quot;的16进制ascii码,下pkg同。同样的\u0026quot;7%\u0026hellip;\u0026hellip;\u0026ldquo;为\u0026quot;0x0000 37 25 00 00 00 00 00 00\u0026quot;的表示。 ","date":"2021-12-13T11:15:06Z","permalink":"https://60ke.github.io/posts/go%E6%B1%87%E7%BC%96/","title":"go汇编"},{"content":"ANTLR（全名：ANother Tool for Language Recognition）是基于LL(*)算法实现的语法解析器生成器（parser generator）,用Java语言编写,使用自上而下（top-down）的递归下降LL剖析器方法。由旧金山大学的Terence Parr博士等人于1989年开始发展。 目前网上的antlr示例大多为java,python,c++等,其github上虽有关于go的一个文档:go-target.md,但是是基于listener模式实现的,而本文是基于visitor实现的一个简单计算器\ninstall antlr 安装java antlr是基于Java开发的的,其运行依赖java环境。 当前(2021年05月11日18:39:11) mac可使用homebrew命令brew install openjdk但是M1的openjdk兼容性有问题,使用antlr生成AST树的图片时总会异常退出,最终选择使用Azul Zulu的dmg二进制安装可正常运行\n安装antlr antlr官网首页已经给出了安装教程:\n1 2 3 4 5 6 OS X $ cd /usr/local/lib $ sudo curl -O https://www.antlr.org/download/antlr-4.9.2-complete.jar $ export CLASSPATH=\u0026#34;.:/usr/local/lib/antlr-4.9.2-complete.jar:$CLASSPATH\u0026#34; $ alias antlr4=\u0026#39;java -jar /usr/local/lib/antlr-4.9.2-complete.jar\u0026#39; $ alias grun=\u0026#39;java org.antlr.v4.gui.TestRig\u0026#39; 运行示例测试 编写Expr.g4 1 2 3 4 5 6 7 8 9 grammar Expr;\tprog:\t(expr NEWLINE)* ; expr:\texpr (\u0026#39;*\u0026#39;|\u0026#39;/\u0026#39;) expr |\texpr (\u0026#39;+\u0026#39;|\u0026#39;-\u0026#39;) expr |\tINT |\t\u0026#39;(\u0026#39; expr \u0026#39;)\u0026#39; ; NEWLINE : [\\r\\n]+ ; INT : [0-9]+ ; 运行antlr工具 1 2 3 4 $ antlr4 Expr.g4 $ javac Expr*.java $ grun Expr prog -gui 100+2*34 ctrl + d看到AST图片 ,说明我们antlr安装成功且可以正常运行。 golang visitor实现 antlr grammar文件编写 1 2 3 4 5 6 7 8 9 10 11 12 grammar Calculantlr; // non-terminals expressed as context-free grammar (BNF) expr:\tleft=expr op=(\u0026#39;*\u0026#39;|\u0026#39;/\u0026#39;) right=expr # OpExpr |\tleft=expr op=(\u0026#39;+\u0026#39;|\u0026#39;-\u0026#39;) right=expr # OpExpr |\tatom=INT # AtomExpr |\t\u0026#39;(\u0026#39; expr \u0026#39;)\u0026#39; # ParenExpr ; // tokens expressed as regular expressions INT : [0-9]+ ; WS : [ \\t]+ -\u0026gt; skip ; 使用antlr生成相关的go文件 antlr4 -Dlanguage=Go -o parser -package parser -visitor -no-listener Expression.g4 上面的命令参数作用一目了然不在赘述,需要注意的是antlr默认会生成listenner模式的相关文件,所以我们使用了-no-listener参数阻止\n编写go的main程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 package main import ( \u0026#34;antlrtest/parser\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;github.com/antlr/antlr4/runtime/Go/antlr\u0026#34; ) type Visitor struct { parser.CalculantlrVisitor } func (v *Visitor) Visit(tree antlr.ParseTree) float64 { switch val := tree.(type) { case *parser.AtomExprContext: return v.VisitAtomExpr(val) case *parser.ParenExprContext: return v.VisitParenExpr(val) case *parser.OpExprContext: return v.VisitOpExpr(val) default: panic(\u0026#34;Unknown context\u0026#34;) } } func (v *Visitor) VisitAtomExpr(ctx *parser.AtomExprContext) float64 { fmt.Println(\u0026#34;atom\u0026#34;, ctx.GetText()) i1, _ := strconv.ParseFloat(ctx.GetText(), 64) return i1 } func (v *Visitor) VisitParenExpr(ctx *parser.ParenExprContext) float64 { fmt.Println(\u0026#34;parent\u0026#34;, ctx.GetText()) tar := v.Visit(ctx.Expr()) return tar } func (v *Visitor) VisitOpExpr(ctx *parser.OpExprContext) float64 { // fmt.Println(\u0026#34;op\u0026#34;) l := v.Visit(ctx.GetLeft()) r := v.Visit(ctx.GetRight()) op := ctx.GetOp().GetText() // if op == \u0026#34;+\u0026#34; { // return l + r // } fmt.Println(\u0026#34;op\u0026#34;, op) switch op { case \u0026#34;+\u0026#34;: return l + r case \u0026#34;-\u0026#34;: return l - r case \u0026#34;*\u0026#34;: return l * r case \u0026#34;/\u0026#34;: return l / r } return 0 } // func (this *TreeShapeListener) EnterEveryRule(ctx antlr.ParserRuleContext) { // fmt.Println(ctx.GetText()) // } func main() { expression := \u0026#34;100 + 3 * 4 + 5\u0026#34; // input, _ := antlr.NewFileStream(os.Args[1]) input := antlr.NewInputStream(expression) lexer := parser.NewCalculantlrLexer(input) stream := antlr.NewCommonTokenStream(lexer, 0) p := parser.NewCalculantlrParser(stream) // p.AddErrorListener(antlr.NewDiagnosticErrorListener(true)) p.BuildParseTrees = true tree := p.Expr() var visitor = Visitor{} var result = visitor.Visit(tree) fmt.Println(expression, \u0026#34;=\u0026#34;, result) } 其它关于go的mod的一些基础操作这里不提,运行go run test.go可以看到以下输出\n1 2 3 4 5 6 7 8 atom 100 atom 3 atom 4 op * op + atom 5 op + 100 + 3 * 4 + 5 = 117 ","date":"2021-05-11T18:29:58Z","permalink":"https://60ke.github.io/posts/antlr4/","title":"write a antlr4 visitor with golang"},{"content":"并发测试工具 1.Apache ab 2.Python locust 3.nodejs loadtest 4.weighttp 5.Apache JMeter 6.wrk\n并发Web开发 1.Python的并发服务:Flask gevent 多进程WSGI（非gunicorn）,这篇博客已经对并发进行分析测试了,为了防止失联,把代码搬运了:\nserver.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # coding: utf-8 # code by https://cpp.la, 2020-04-20 # flask + gevent + multiprocess + wsgi from gevent import monkey from gevent.pywsgi import WSGIServer monkey.patch_all() import datetime import os from multiprocessing import cpu_count, Process from flask import Flask, jsonify app = Flask(__name__) @app.route(\u0026#34;/\u0026#34;, methods=[\u0026#39;GET\u0026#39;]) def function_benchmark(): return \u0026#34;hello\u0026#34; def run(MULTI_PROCESS): if MULTI_PROCESS == False: WSGIServer((\u0026#39;0.0.0.0\u0026#39;, 8080), app).serve_forever() else: mulserver = WSGIServer((\u0026#39;0.0.0.0\u0026#39;, 8080), app) mulserver.start() def server_forever(): mulserver.start_accepting() mulserver._stop_event.wait() for i in range(cpu_count()): p = Process(target=server_forever) p.start() if __name__ == \u0026#34;__main__\u0026#34;: # 单进程 + 协程 run(False) # 多进程 + 协程 # run(True) 2.RUST并发服务 rust actix\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 use actix_web::{get, web, App, HttpServer, Responder}; #[get(\u0026#34;/\u0026#34;)] async fn index(web::Path((id, name)): web::Path\u0026lt;(u32, String)\u0026gt;) -\u0026gt; impl Responder { format!(\u0026#34;Hello {}! id:{}\u0026#34;, name, id) } #[actix_web::main] async fn main() -\u0026gt; std::io::Result\u0026lt;()\u0026gt; { HttpServer::new(|| App::new().service(index)) .bind(\u0026#34;127.0.0.1:8080\u0026#34;)? .run() .await } actix 测试结果:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 wrk -c100 -t16 -d5s http://127.0.0.1:8080 Running 5s test @ http://127.0.0.1:8080 16 threads and 100 connections Thread Stats Avg Stdev Max +/- Stdev Latency 692.92us 671.89us 27.97ms 98.85% Req/Sec 9.29k 829.44 20.49k 97.03% 746546 requests in 5.10s, 58.38MB read Non-2xx or 3xx responses: 746546 Requests/sec: 146385.73 Transfer/sec: 11.45MB ./wrk -c1000 -t16 -d5s http://127.0.0.1:8080 Running 5s test @ http://127.0.0.1:8080 16 threads and 1000 connections Thread Stats Avg Stdev Max +/- Stdev Latency 6.37ms 1.98ms 78.58ms 93.94% Req/Sec 9.54k 3.48k 86.90k 92.16% 763414 requests in 5.10s, 59.70MB read Non-2xx or 3xx responses: 763414 Requests/sec: 149702.90 Transfer/sec: 11.71MB 测试机器为8核16线程的服务器,可以看到actix的性能还是相当强大的.另外突然想到了一个问题 Linux中本机和本机Socket通信会走网卡吗？\n并发测试 起先用了loadtest测试,关于Apache ab,weighttp的性能loadtest中有提到,感觉并不理想,后来使用wrk发现性能更强,故使用wrk测试.wrk支持lua脚本的嵌入调用,支持post,get,等调用,亦可使用lua脚本同时对多个接口进行测试.\nmul.lua多接口测试脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 -- Resource: http://czerasz.com/2015/07/19/wrk-http-benchmarking-tool-example/ -- Module instantiation local cjson = require \u0026#34;cjson\u0026#34; local cjson2 = cjson.new() local cjson_safe = require \u0026#34;cjson.safe\u0026#34; -- Initialize the pseudo random number generator -- Resource: http://lua-users.org/wiki/MathLibraryTutorial math.randomseed(os.time()) math.random(); math.random(); math.random() -- Shuffle array -- Returns a randomly shuffled array function shuffle(paths) local j, k local n = #paths for i = 1, n do j, k = math.random(n), math.random(n) paths[j], paths[k] = paths[k], paths[j] end return paths end -- Load URL paths from the file function load_request_objects_from_file(file) local data = {} local content -- Check if the file exists -- Resource: http://stackoverflow.com/a/4991602/325852 local f=io.open(file,\u0026#34;r\u0026#34;) if f~=nil then content = f:read(\u0026#34;*all\u0026#34;) io.close(f) else -- Return the empty array return lines end -- Translate Lua value to/from JSON data = cjson.decode(content) return shuffle(data) end -- Load URL requests from file requests = load_request_objects_from_file(\u0026#34;./data/requests.json\u0026#34;) -- Check if at least one path was found in the file if #requests \u0026lt;= 0 then print(\u0026#34;multiplerequests: No requests found.\u0026#34;) os.exit() end print(\u0026#34;multiplerequests: Found \u0026#34; .. #requests .. \u0026#34; requests\u0026#34;) -- Initialize the requests array iterator counter = 1 request = function() -- Get the next requests array element local request_object = requests[counter] -- Increment the counter counter = counter + 1 -- If the counter is longer than the requests array length then reset it if counter \u0026gt; #requests then counter = 1 end -- Return the request object with the current URL path return wrk.format(request_object.method, request_object.path, request_object.headers, request_object.body) end 上面脚本依赖lua的cjson包,其目的是解析/data/requests.json构造对应的request请求.\n/data/requests.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 [ { \u0026#34;path\u0026#34;: \u0026#34;/path-1\u0026#34;, \u0026#34;body\u0026#34;: \u0026#34;{\\\u0026#34;quote\\\u0026#34;: \\\u0026#34;\\\u0026#34;}\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;POST\u0026#34;, \u0026#34;headers\u0026#34;: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34; } }, { // path 为web服务的url路径 \u0026#34;path\u0026#34;: \u0026#34;/path-2\u0026#34;, \u0026#34;body\u0026#34;: \u0026#34;{\\\u0026#34;quote\\\u0026#34;: \\\u0026#34;\\\u0026#34;}\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;POST\u0026#34;, \u0026#34;headers\u0026#34;: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34; } } ] 测试命令 ./wrk -c100 -t16 -d5s -s ./mul.lua http://127.0.0.1:5000\n-c:(concurrent)并发数\n-t:(threads)线程数\n-d:(duration)持续时间\n其它具体使用方法可去看文档及示例: https://github.com/wg/wrk\n疑问 测试actix时,cpu,内存,网络占用,都特别低,cpu使用百分之一不到,说明程序还远未达到硬件的性能瓶颈 Linux的性能测试工具 Perf\n","date":"2021-01-22T14:55:28Z","permalink":"https://60ke.github.io/posts/%E9%AB%98%E6%80%A7%E8%83%BDweb%E6%9C%8D%E5%8A%A1%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%B5%8B%E8%AF%95/","title":"高性能web服务与并发测试"},{"content":"准备 解析wasm字节码 wasm概览 wasm指令集 wasm类型 wasm包含12种section: 每个section包括:\nsection id(大小1字节) section size(格式为u32记录section大小) data(section中保存的内容,格式取决于section id) 每个 section 都是可选的, 如果某个 wasm 模块省略了某个 section, 则等同于存在一个内容为空的 section.\nhttps://wasdk.github.io/WasmFiddle/?这个网站可以编译c/c++为wasm格式。 用一个简单的例子来说明对wasm二进制的解析:\n1 2 3 int main() { return 42; } 对应的wast格式:\n1 2 3 4 5 6 7 8 9 (module (table 0 anyfunc) (memory $0 1) (export \u0026#34;memory\u0026#34; (memory $0)) (export \u0026#34;main\u0026#34; (func $main)) (func $main (; 0 ;) (result i32) (i32.const 42) ) ) 对应的二进制: 二进制码:\n1 [\u0026#39;0x0\u0026#39;, \u0026#39;0x61\u0026#39;, \u0026#39;0x73\u0026#39;, \u0026#39;0x6d\u0026#39;, \u0026#39;0x1\u0026#39;, \u0026#39;0x0\u0026#39;, \u0026#39;0x0\u0026#39;, \u0026#39;0x0\u0026#39;, \u0026#39;0x1\u0026#39;, \u0026#39;0x85\u0026#39;, \u0026#39;0x80\u0026#39;, \u0026#39;0x80\u0026#39;, \u0026#39;0x80\u0026#39;, \u0026#39;0x0\u0026#39;, \u0026#39;0x1\u0026#39;, \u0026#39;0x60\u0026#39;, \u0026#39;0x0\u0026#39;, \u0026#39;0x1\u0026#39;, \u0026#39;0x7f\u0026#39;, \u0026#39;0x3\u0026#39;, \u0026#39;0x82\u0026#39;, \u0026#39;0x80\u0026#39;, \u0026#39;0x80\u0026#39;, \u0026#39;0x80\u0026#39;, \u0026#39;0x0\u0026#39;, \u0026#39;0x1\u0026#39;, \u0026#39;0x0\u0026#39;, \u0026#39;0x4\u0026#39;, \u0026#39;0x84\u0026#39;, \u0026#39;0x80\u0026#39;, \u0026#39;0x80\u0026#39;, \u0026#39;0x80\u0026#39;, \u0026#39;0x0\u0026#39;, \u0026#39;0x1\u0026#39;, \u0026#39;0x70\u0026#39;, \u0026#39;0x0\u0026#39;, \u0026#39;0x0\u0026#39;, \u0026#39;0x5\u0026#39;, \u0026#39;0x83\u0026#39;, \u0026#39;0x80\u0026#39;, \u0026#39;0x80\u0026#39;, \u0026#39;0x80\u0026#39;, \u0026#39;0x0\u0026#39;, \u0026#39;0x1\u0026#39;, \u0026#39;0x0\u0026#39;, \u0026#39;0x1\u0026#39;, \u0026#39;0x6\u0026#39;, \u0026#39;0x81\u0026#39;, \u0026#39;0x80\u0026#39;, \u0026#39;0x80\u0026#39;, \u0026#39;0x80\u0026#39;, \u0026#39;0x0\u0026#39;, \u0026#39;0x0\u0026#39;, \u0026#39;0x7\u0026#39;, \u0026#39;0x91\u0026#39;, \u0026#39;0x80\u0026#39;, \u0026#39;0x80\u0026#39;, \u0026#39;0x80\u0026#39;, \u0026#39;0x0\u0026#39;, \u0026#39;0x2\u0026#39;, \u0026#39;0x6\u0026#39;, \u0026#39;0x6d\u0026#39;, \u0026#39;0x65\u0026#39;, \u0026#39;0x6d\u0026#39;, \u0026#39;0x6f\u0026#39;, \u0026#39;0x72\u0026#39;, \u0026#39;0x79\u0026#39;, \u0026#39;0x2\u0026#39;, \u0026#39;0x0\u0026#39;, \u0026#39;0x4\u0026#39;, \u0026#39;0x6d\u0026#39;, \u0026#39;0x61\u0026#39;, \u0026#39;0x69\u0026#39;, \u0026#39;0x6e\u0026#39;, \u0026#39;0x0\u0026#39;, \u0026#39;0x0\u0026#39;, \u0026#39;0xa\u0026#39;, \u0026#39;0x8a\u0026#39;, \u0026#39;0x80\u0026#39;, \u0026#39;0x80\u0026#39;, \u0026#39;0x80\u0026#39;, \u0026#39;0x0\u0026#39;, \u0026#39;0x1\u0026#39;, \u0026#39;0x84\u0026#39;, \u0026#39;0x80\u0026#39;, \u0026#39;0x80\u0026#39;, \u0026#39;0x80\u0026#39;, \u0026#39;0x0\u0026#39;, \u0026#39;0x0\u0026#39;, \u0026#39;0x41\u0026#39;, \u0026#39;0x2a\u0026#39;, \u0026#39;0xb\u0026#39;] 一步步分析: 前八个字节表示的东西是固定的。'0x0', '0x61', '0x73', '0x6d'前四个字节表示\\0asm.'0x1', '0x0', '0x0', '0x0'表示为1的版本号。\nwasm采用LEB128编码: 谷歌为了省点空间,在安卓中用了这个压缩标准,其原理就是一个4字节32位的数字,一般很少占满,比如数字1,2等,它其实用几位就可以表示。下面看看它的工作原理： 1）忽略高字节的正负代表位。 2）每七位组成一组,待编码。 3）有符号和无符号的分成不同的情况来处理。 4）无符号,最高位为0表示结束,1表示还有后续字节。待编码的七位为数据。 5）有符号的处理,同上,但需要处理高位为0的不同情况。 6）有符号的处理,同上,需要处理高位为1的不同情况。 从上面可以看出无符号比较简单,有符号还需要处理几种情况,这里举一个无符号的例子,简单理解一下,更多请查阅相关资料： 编码： 十六进制数字：0x238 ========\u0026gt; 二进制 0000 0010 0011 1000 分成两个七位的组：0000100(高位), 0111000（低位） 0000100后面没数据了,所以前面加一个0；0111000后面还有一个字节,所以高为为1,则变为： 00000100(即：0x04),10111000(0x70)\n则小端存放的数据为：0x70,0x04 解码： 正好相反,把数据拆开,按编码逆向过程即可。\n对于rust,我们可以直接用现有的crate:parity-wasm对wasm进行解析。\nwasm解析器 wasmi\n可运行wasm的虚拟机 vm\n生成可被wasmi执行的合约 pwasm-abi 使用过程宏生成类型solidity合约代码结构的rust合约,并最终编译为wasm-unkonwn-unkonwn(wasm).\n最终生成的合约:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #![no_std] #![allow(non_snake_case)] #![feature(proc_macro_hygiene)] extern crate pwasm_std; extern crate pwasm_ethereum; extern crate pwasm_abi; extern crate pwasm_abi_derive; extern crate alloc; pub mod array { use pwasm_ethereum; use pwasm_abi::types::*; use pwasm_abi_derive::eth_abi; use alloc::collections::BTreeMap; use alloc::format; #[eth_abi(TokenEndpoint, TokenClient)] pub trait ArrayInterface { fn constructor(\u0026amp;mut self); fn double_array(\u0026amp;mut self,x:U256,y:U256)-\u0026gt; U256; } pub struct ArrayContract; impl ArrayInterface for ArrayContract{ fn double_array(\u0026amp;mut self,x:U256,y:U256) -\u0026gt; U256{ U256::from(x) + U256::from(x) } fn constructor(\u0026amp;mut self) { } } } use pwasm_abi::eth::EndpointInterface; #[no_mangle] pub fn call() { let mut endpoint = array::TokenEndpoint::new(array::ArrayContract{}); // Read http://solidity.readthedocs.io/en/develop/abi-spec.html#formal-specification-of-the-encoding for details pwasm_ethereum::ret(\u0026amp;endpoint.dispatch(\u0026amp;pwasm_ethereum::input())); } #[no_mangle] pub fn deploy() { let mut endpoint = array::TokenEndpoint::new(array::ArrayContract{}); endpoint.dispatch_ctor(\u0026amp;pwasm_ethereum::input()); } 上面的合约通过eth_abi这个过程宏生成了wasm合约. 宏展开的部分代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 fn dispatch(\u0026amp;mut self, payload: \u0026amp;[u8]) -\u0026gt; Vec\u0026lt;u8\u0026gt; { let inner = \u0026amp;mut self.inner; if payload.len() \u0026lt; 4 { ::core::panicking::panic(\u0026#34;Invalid abi invoke\u0026#34;); } let method_id = ((payload[0] as u32) \u0026lt;\u0026lt; 24) + ((payload[1] as u32) \u0026lt;\u0026lt; 16) + ((payload[2] as u32) \u0026lt;\u0026lt; 8) + (payload[3] as u32); let method_payload = \u0026amp;payload[4..]; match method_id { 870935635u32 =\u0026gt; { if pwasm_ethereum::value() \u0026gt; 0.into() { ::core::panicking::panic( \u0026#34;Unable to accept value in non-payable constructor call\u0026#34;, ); } let mut stream = pwasm_abi::eth::Stream::new(method_payload); let result = inner.double_array( stream.pop::\u0026lt;U256\u0026gt;().expect(\u0026#34;argument decoding failed\u0026#34;), stream.pop::\u0026lt;U256\u0026gt;().expect(\u0026#34;argument decoding failed\u0026#34;), ); let mut sink = pwasm_abi::eth::Sink::new(1usize); sink.push(result); sink.finalize_panicking() } _ =\u0026gt; ::core::panicking::panic(\u0026#34;Invalid method signature\u0026#34;), } } fn double_array(\u0026amp;mut self, x: U256, y: U256) -\u0026gt; U256 { #![allow(unused_mut)] #![allow(unused_variables)] let mut payload = Vec::with_capacity(4 + 2usize * 32); payload.push((870935635u32 \u0026gt;\u0026gt; 24) as u8); payload.push((870935635u32 \u0026gt;\u0026gt; 16) as u8); payload.push((870935635u32 \u0026gt;\u0026gt; 8) as u8); payload.push(870935635u32 as u8); let mut sink = pwasm_abi::eth::Sink::new(2usize); sink.push(x); sink.push(y); sink.drain_to(\u0026amp;mut payload); let mut result = [0u8; 32]; pwasm_ethereum::call( self.gas.unwrap_or(200000), \u0026amp;self.address, self.value.clone().unwrap_or(U256::zero()), \u0026amp;payload, \u0026amp;mut result[..], ) .expect(\u0026#34;Call failed; todo: allow handling inside contracts\u0026#34;); let mut stream = pwasm_abi::eth::Stream::new(\u0026amp;result); stream.pop().expect(\u0026#34;failed decode call output\u0026#34;) } 在合约编译的内部实现中通过需要通过eth_abi接口将函数重命名. 这样我们在调用合约时,通过eth_abi编码的数据才能被合约识别运行.\nweb3eth_abi编码\nwasm-build 已生成的wasm合约不能直接被vm运行,wasm-build将由pwasm写的合约再次处理转化为可被vm执行的wasm合约文件.\nwasm-build的工作: 1.解析wasm module提取以下section:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 while let Some(section) = sections.pop() { match section { elements::Section::Type(sect) =\u0026gt; { types = Some(sect); } elements::Section::Import(sect) =\u0026gt; { import = Some(sect); } elements::Section::Function(sect) =\u0026gt; { funcs = Some(sect); } elements::Section::Table(sect) =\u0026gt; { table = Some(sect); } elements::Section::Memory(sect) =\u0026gt; { memory = Some(sect); } elements::Section::Global(sect) =\u0026gt; { global = Some(sect); } elements::Section::Export(sect) =\u0026gt; { export = Some(sect); } elements::Section::Start(index) =\u0026gt; { start = Some(index); } elements::Section::Element(sect) =\u0026gt; { element = Some(sect); } elements::Section::Code(sect) =\u0026gt; { code = Some(sect); } elements::Section::Data(sect) =\u0026gt; { data = Some(sect); } _ =\u0026gt; {} } } 将wasm的module优化为:\nType Import Function Table Memory Global Export Start Code Data other 2.优化函数名及构造函数deploy,call,end等模块.\n","date":"2020-09-22T11:05:04Z","permalink":"https://60ke.github.io/posts/ewasm%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BC%80%E5%8F%91/","title":"ewasm虚拟机开发"},{"content":"用户代码片段 之前在sublime上常用tmpl插件来新建python文件,文件默认包含头文件模板。vscode可以直接添加与文件相关的代码片段。 python用户代码片段:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 { \u0026#34;HEADER\u0026#34;:{ \u0026#34;prefix\u0026#34;: \u0026#34;header\u0026#34;, \u0026#34;body\u0026#34;: [ \u0026#34;#!/usr/bin/env python\u0026#34;, \u0026#34;# -*- encoding: utf-8 -*-\u0026#34;, \u0026#34;\u0026#39;\u0026#39;\u0026#39;\u0026#34;, \u0026#34;@File : $TM_FILENAME\u0026#34;, \u0026#34;@Time : $CURRENT_YEAR/$CURRENT_MONTH/$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND\u0026#34;, \u0026#34;@Author : worileqing\u0026#34;, \u0026#34;@Version : 1.0\u0026#34;, \u0026#34;@Contact : worileqing@163.com\u0026#34;, \u0026#34;@Desc : None\u0026#34;, \u0026#34;\u0026#39;\u0026#39;\u0026#39;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;# here put the import lib\u0026#34;, \u0026#34;$0\u0026#34; ], } } markdown用户代码片段:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;HEADER\u0026#34;:{ \u0026#34;prefix\u0026#34;: \u0026#34;date\u0026#34;, \u0026#34;body\u0026#34;: [ \u0026#34;date : $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND\u0026#34;, ], }, \u0026#34;HEADER\u0026#34;:{ \u0026#34;prefix\u0026#34;: \u0026#34;code is\u0026#34;, \u0026#34;body\u0026#34;: [ \u0026#34;code is cheap,show code:\u0026#34;, ], } } 但是创建完成配置未能在markdown中生效,解决办法: 在setting.json中添加:\n1 2 3 4 5 6 7 \u0026#34;[markdown]\u0026#34;: { \u0026#34;editor.quickSuggestions\u0026#34;: { \u0026#34;other\u0026#34;: true, \u0026#34;comments\u0026#34;: false, \u0026#34;strings\u0026#34;: true }, }, coder runner 可以在任意类型的文件里面选中代码 code run by some language\n","date":"2020-09-18T14:29:16Z","permalink":"https://60ke.github.io/posts/vscode%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/","title":"vscode奇技淫巧"},{"content":"Enclave开发包括以下几个步骤： 使用EDL文件定义不可信app和encalve(飞地)之间的接口(由ecall和ocall来实现) 实现app和encalve函数。 编译app和enclave。编译中,Edger8r生成可信和不可信的代理/桥函数,enclave签名工具生成enclave的metadata和签名。需生成Enclave_private.pem 在模拟和硬件模式下运行和调试app,详细看看调试飞地的内容。 准备发布app和飞地。 名词解释 EDL 即 Enclave Defination Language. 因为 Enclave 不同于共享的资源, 其与外部不可信内容的交互需要特定的规则进行限定. Intel SGX 给出了一种语言来抽象地描述 Enclave 内部函数的调用权限和数据的出入方式, 并通过 sgx_edger8r 翻译成一系列可编译的代码. EDL 提出了一种“边规则”(edge routine) 的概念. 一个 edge routine 即是运行于 Enclave 内部或外部的函数和它们与 Enclave 外部或内部的调用关系的总称.\necall（Enclave Call） 是 Enclave 内部程序的接口函数.\nocall （Out Call）是可由 Enclave 内部代码调用的外部函数接口.\n具体开发实例 https://github.com/60ke/rust_sgx_test/tree/master/ocall_beta\n此实例是基于incubator-teaclave-sgx-sdk 即baidu rust sdk开发\n开发流程：\n首先需要放置基础依赖common/inc（c的头文件）和 edl 使用rust编写 app 和 encalve 编写Makefile文件(可参考Makefile) 1 和 3 的开发相对简单,不再具体描述。下面介绍使用rust编写 app 和 encalve\n代码结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ├── .vscode-------------------------- vscode配置文件,用于debug ├── Cargo.toml-------------------------- 定义workspace用于debug ├── Makefile-------------------------- 项目编译 ├── app │ ├── Cargo.toml-------------------------- app的cargo配置 │ ├── build.rs-------------------------- app的build文件 │ └── src -------------------------- rust代码目录 │ └── main.rs-------------------------- app主函数文件 ├── bin-------------------------- 存放编译后的二进制文件夹 ├── common-------------------------- 引用自[common/inc](https://github.com/mesalock-linux/adler32-rs-sgx/tree/master/sgx/adler32-rs-sgx-test/common/inc) ├── edl-------------------------- 引用自[edl](https://github.com/mesalock-linux/adler32-rs-sgx/tree/master/sgx/adler32-rs-sgx-test/edl) ├── enclave │ ├── Cargo.toml-------------------------- enclave的cargo配置 │ ├── Enclave.config.xml--------------定义 Enclave 的内存布局等高级特性 │ ├── Enclave.edl--------------Edl文件 │ ├── Enclave.lds--------------encalve链接脚本 │ ├── Enclave_private.pem------------用户生成的私匙供 sgxsdk 签名使用 │ ├── Makefile -------------------------- Encalve编译 │ └── src -------------------------- rust代码目录 │ └── lib.rs-------------------------- enclave的lib文件 首先在encalve的Enclave.edl中定义ecall和ocall函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 enclave { //导入引用 from \u0026#34;sgx_tstd.edl\u0026#34; import *; from \u0026#34;sgx_stdio.edl\u0026#34; import *; from \u0026#34;sgx_backtrace.edl\u0026#34; import *; from \u0026#34;sgx_tstdc.edl\u0026#34; import *; include \u0026#34;sgx_quote.h\u0026#34; trusted { //定义ecall public sgx_status_t say_something([in, size=len] const uint8_t* some_string, size_t len); }; untrusted { //定义ocall void ocall_get_quote([in, size = key_len] uint8_t * key,uint32_t key_len,[out,size = 1000] uint8_t* value,[out] uint8_t* value_len); }; }; ecall的入口在app部分,函数的具体实现在enclave中。先看ecall的edl函数定义：\n1 public sgx_status_t say_something([in, size=len] const uint8_t* some_string, size_t len); 这里ecall的调用传入的是一个c语言的常量字符串,为了便于c与rust的交互我们将char list(常量字符串)转换为ASCII码以指针的形式传递。这里的ecall直接使用incubator-teaclave-sgx-sdk中的Enclave.edl 首先声明public,返回的数据类型为sgx_status_t 函数名为say_something.ecall传入enclave需要用[in]修饰。由于我们传入的为常量需要加上size的参数size=len Edl的语法和C语言语法比较接近uint8_t*和size_t为数据类型,some_string 和为变量名len.\nenclave的say_something实现：lib.rs,然后在app中引入：\n1 2 3 4 extern { fn say_something(eid: sgx_enclave_id_t, retval: *mut sgx_status_t, some_string: *const u8, len: usize) -\u0026gt; sgx_status_t; } 然后在main.rs中的main函数对其调用。\nocall的入口在enclave中,函数在app中实现。其Edl部分为：\n1 void ocall_get_quote([in, size = key_len] uint8_t * key,uint32_t key_len,[out,size = 1000] uint8_t* value,[out] uint8_t* value_len); ocall的实现的功能为由enclave传出一个key到app,然后app生成一个对应的value再传入enclave。整体流程与ecall类似。需要注意的是,由于value的长度不固定,不能单纯定义为一个常量的类型。我们这里先定义了一个足够大的list（1000）,然后再传递一个变量value_len来表示value的长度。然后在enclave对其进行截取来实现value由app到enclave的返回。\n参考 https://blog.lao-yuan.com/2019/02/20/Linux-SGX-Demo.html#edl https://zhuanlan.zhihu.com/p/39914622\n","date":"2020-01-17T16:58:55Z","permalink":"https://60ke.github.io/posts/enclave%E5%BC%80%E5%8F%91/","title":"Enclave开发"},{"content":"sgx 开发 当前项目依赖： incubator-teaclave-sgx-sdk 1.0.9(原baidu rust sgx sdk)\nRust nightly-2019-08-01\nhttps://github.com/enigmampc/enigma-core 的一些crate(后续开发剔除)\n适用于rust sgx的crate：\nhttps://github.com/dingelish/sgx-world\n项目开发遇到的问题 evm读写集的记录： 在sputnikvm的返回结果上添加读写集。可对比 https://github.com/60ke/sputnikvm 与 https://github.com/enigmampc/sputnikvm/tree/enigma-next 的区别\nocall： 传入address和storage的key来获取storage的value的edl部分的代码：\n1 2 3 4 5 void ocall_get_storage( [in, size = addr_len] uint8_t * addr,uint8_t addr_len, [in, size = index_len] uint8_t * index,uint8_t index_len, [out,size = 1000] uint8_t* value,[out] uint8_t* value_len ); enclave与外界的数据类型交互： 由edl生成c函数,通过指针的方法进行进行交互\nsolidity测试合约 regchain wiki中的合约：\n1 2 3 4 5 6 7 8 pragma solidity ^0.4.24; contract sample { uint256 a = 0; function add() payable public returns (uint256) { a = a + msg.value; return a; } } 需要操作storage的合约：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 pragma solidity ^0.4.24; contract MyContract { uint[] array = [1,2,3,4,5]; function removeAtIndex(uint index) returns (uint[]) { if (index \u0026gt;= array.length) return; for (uint i = index; i \u0026lt; array.length-1; i++) { array[i] = array[i+1]; } delete array[array.length-1]; array.length--; return array; } } 利用vscode和sgx-gdb进行调试 教程：\nSetup gdb 7.11 on Ubuntu 18.04 for VSCode sgx gdb remote debugging\n对应代码实例：\nhello-rust-vscode-debug\nintel远程证实 英特尔官方远程证实 注册英特尔开发者账号获取spid和key:\nhttps://software.intel.com/registration/?lang=zh-cn\nintel官方实例：https://software.intel.com/zh-cn/articles/code-sample-intel-software-guard-extensions-remote-attestation-end-to-end-example\nRust sgx相关代码实例：\nmutual-ra\nue-ra\n第三方远程证实（dcap） https://github.com/intel/SGXDataCenterAttestationPrimitives\nSgx第三方远程证实硬件说明\nARM TrustZone: OP-TEE / optee_os\nARMmbed / meta-mbl\nhttps://blog.csdn.net/shuaifengyun/article/details/73716352\n","date":"2020-01-17T16:46:35Z","permalink":"https://60ke.github.io/posts/sgx/","title":"sgx开发"},{"content":"MySQL5.7.22数据库安装完后更改密码；\nALTER USER USER() IDENTIFIED BY '12345678';\n","date":"2019-07-10T11:20:46Z","permalink":"https://60ke.github.io/posts/mysql/","title":"MySQL"},{"content":" 1 2 3 4 5 6 7 8 9 10 import paramiko ssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) host_ips = \u0026#34;127.0.0.1\u0026#34; username = \u0026#34;admin\u0026#34; password = \u0026#34;admin\u0026#34; port = 22 ssh.connect(host_ip,port,username,password) stdin, stdout, stderr = ssh.exec_command(\u0026#34;sudo -S -p \u0026#39;\u0026#39; service redis restart;\u0026#34;) #stdout.read()可以获取输出内容 注意执行带有 sudo的 ssh.exec_command()时需要在命令前加 sudo -S -p '' ","date":"2019-05-28T12:00:26Z","permalink":"https://60ke.github.io/posts/paramiko-%E6%89%A7%E8%A1%8Csudo/","title":"paramiko 执行sudo"}]