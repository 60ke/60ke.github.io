<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>rust on LookForAdmin的博客</title><link>https://60ke.github.io/tags/rust/</link><description>Recent content in rust on LookForAdmin的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 08 Nov 2021 11:27:50 +0000</lastBuildDate><atom:link href="https://60ke.github.io/tags/rust/index.xml" rel="self" type="application/rss+xml"/><item><title>跨平台编译</title><link>https://60ke.github.io/drafts/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/</link><pubDate>Mon, 08 Nov 2021 11:27:50 +0000</pubDate><guid>https://60ke.github.io/drafts/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/</guid><description>golang跨平台编译 运行go tool dist list查看golang当前支持的平台 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 aix/ppc64 android/386 android/amd64 android/arm android/arm64 darwin/amd64 darwin/arm64 dragonfly/amd64 freebsd/386 freebsd/amd64 freebsd/arm freebsd/arm64 illumos/amd64 ios/amd64 ios/arm64 js/wasm linux/386 linux/amd64 linux/arm linux/arm64 linux/mips linux/mips64 linux/mips64le linux/mipsle linux/ppc64 linux/ppc64le linux/riscv64 linux/s390x netbsd/386 netbsd/amd64 netbsd/arm netbsd/arm64 openbsd/386 openbsd/amd64 openbsd/arm openbsd/arm64 openbsd/mips64 plan9/386 plan9/amd64 plan9/arm solaris/amd64 windows/386 windows/amd64 windows/arm windows/arm64 额外的说一句,go竟然支持i</description></item><item><title>go调用RUST</title><link>https://60ke.github.io/drafts/go%E8%B0%83%E7%94%A8RUST/</link><pubDate>Tue, 06 Apr 2021 10:46:59 +0000</pubDate><guid>https://60ke.github.io/drafts/go%E8%B0%83%E7%94%A8RUST/</guid><description>无参函数调用 先写一个rust的lib项目生成动态库 1 cargo new --lib embed Cargo.toml 1 2 3 4 5 6 7 8 9 10 11 12 13 [package] name = &amp;#34;embed&amp;#34; version = &amp;#34;0.1.0&amp;#34; authors = [&amp;#34;k &amp;lt;2589788697@qq.com&amp;gt;&amp;#34;] edition = &amp;#34;2018&amp;#34; # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] [lib] name = &amp;#34;embed&amp;#34; crate-type = [&amp;#34;dylib&amp;#34;] lib.rs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 use std::thread; #[no_mangle] fn process(){ let handles:Vec&amp;lt;_&amp;gt;=(0..=10).map(|_|{ thread::spawn(||{ let mut x = 0; for _ in 0..5000000{ x += 1 } x }) }).collect(); for h in handles{ println!(&amp;#34;thread finished with count={}&amp;#34;,h.join().map_err(|_|&amp;#34;could not join a thread&amp;#34;).unwrap()); } } 编译 运行 cargo build -</description></item><item><title>M1-vscode-lldb</title><link>https://60ke.github.io/drafts/M1-vscode-lldb/</link><pubDate>Thu, 18 Mar 2021 09:55:14 +0000</pubDate><guid>https://60ke.github.io/drafts/M1-vscode-lldb/</guid><description>M1的vscode商店中的lldb当前无法直接使用,通过GitHub issue踩坑操作,最终不完美可用(有时候会崩溃) 1.重新编译vscode-lldb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #lvm and vscode-lldb dependecies sudo port install cmake nodejs15 npm6 Building stuff build llvm git clone https://github.com/llvm/llvm-project.git cd llvm-project ; mkdir build ; cd build cmake ../llvm</description></item><item><title>从零实现nosql数据库</title><link>https://60ke.github.io/drafts/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0nosql%E6%95%B0%E6%8D%AE%E5%BA%93/</link><pubDate>Wed, 03 Mar 2021 14:49:43 +0000</pubDate><guid>https://60ke.github.io/drafts/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0nosql%E6%95%B0%E6%8D%AE%E5%BA%93/</guid><description>资料: 如何从零写一个kv数据库？ - cholerae的回答 - 知乎 https://www.zhihu.com/question/59469744/answer/165590616 https://codecapsule.com/2012/11/07/ikvs-implementing-a-key-value-store-table-of-contents/ https://blog.csdn.net/UnSkyToo/article/details/46574209 https://www.lanqiao.cn/courses/1341 https://segmentfault.com/a/1190000004359057 http://www.jos.org.cn/html/2019/9/5776.htm https://zh.wikipedia.org/wiki/计算机科学</description></item><item><title>new_mac</title><link>https://60ke.github.io/drafts/new-mac/</link><pubDate>Fri, 26 Feb 2021 14:41:17 +0000</pubDate><guid>https://60ke.github.io/drafts/new-mac/</guid><description>git等命令安装 1 2 3 4 xcode-select --install sudo xcodebuild -license accept sudo spctl --master-disable #开启任意来源app安装 sudo xattr -rd com.apple.quarantine /Applications/LockedApp.app #另一种开启任意来源app安装 iterm2美化 hack nerd font hexo安装 ohmyzsh安装设置 启用插件 plugins=(git zsh-autosuggestions zsh-syntax-highlighting autojump) shell工具 brew install fzf autojump github ssh key配置 生产public key 1 ssh-keygen -t rsa -C &amp;#34;i505125461@live.com&amp;#34;</description></item><item><title>rust包导入</title><link>https://60ke.github.io/drafts/rust%E5%8C%85%E5%AF%BC%E5%85%A5/</link><pubDate>Wed, 03 Feb 2021 10:30:15 +0000</pubDate><guid>https://60ke.github.io/drafts/rust%E5%8C%85%E5%AF%BC%E5%85%A5/</guid><description>rust 新版本导入包使用,可以不用先extern crate只需在cargo.toml声明,然后可直接用use 我们创建个项目codec_test 当rust中同时存在lib.rs,main.rs时无法使用,use crate::types::* 错误提示: help: a similar path exists: codec_test::types,这是因为在lib.r</description></item><item><title>高性能web服务与并发测试</title><link>https://60ke.github.io/posts/%E9%AB%98%E6%80%A7%E8%83%BDweb%E6%9C%8D%E5%8A%A1%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%B5%8B%E8%AF%95/</link><pubDate>Fri, 22 Jan 2021 14:55:28 +0000</pubDate><guid>https://60ke.github.io/posts/%E9%AB%98%E6%80%A7%E8%83%BDweb%E6%9C%8D%E5%8A%A1%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%B5%8B%E8%AF%95/</guid><description>并发测试工具 1.Apache ab 2.Python locust 3.nodejs loadtest 4.weighttp 5.Apache JMeter 6.wrk 并发Web开发 1.Python的并发服务:Flask gevent 多进程WSGI（非gunicorn）,这篇博客已经对并发进行分析测试了,为了防止失联,把代码搬运了: server.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # coding: utf-8 # code by</description></item><item><title>rust类属性宏</title><link>https://60ke.github.io/drafts/rust%E7%B1%BB%E5%B1%9E%E6%80%A7%E5%AE%8F/</link><pubDate>Fri, 08 Jan 2021 11:18:27 +0000</pubDate><guid>https://60ke.github.io/drafts/rust%E7%B1%BB%E5%B1%9E%E6%80%A7%E5%AE%8F/</guid><description>1.创建macro_test项目 cargo new macro_test 2.创建macro_test_derive项目实现宏的代码逻辑 cargo new macro_test_derive --lib 在macro_test_derive的Cargo.toml中声明lib标识proc-macro 1 2 [lib] crate-type = [&amp;#34;proc-macro&amp;#34;] 也可用 1 2 [lib] proc-macro = true 3.宏逻辑代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17</description></item><item><title>rust num</title><link>https://60ke.github.io/drafts/rust-num/</link><pubDate>Fri, 11 Dec 2020 15:03:43 +0000</pubDate><guid>https://60ke.github.io/drafts/rust-num/</guid><description>开发wasm2ct时遇到了这行代码 1 2 3 construct_uint! { pub struct U256(4); } 宏展开之后为: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 IntellijRustDollarCrate::construct_uint! { @ construct pub struct U256 ( 4 ) ; } impl ::uint::core_::convert::From&amp;lt;u128&amp;gt; for U256 { fn from(value: u128) -&amp;gt; U256 { let mut ret = [0; 4]; ret[0] = value as u64; ret[1] = (value &amp;gt;&amp;gt;</description></item><item><title>rust macro</title><link>https://60ke.github.io/drafts/rust-macro/</link><pubDate>Wed, 02 Dec 2020 18:25:31 +0000</pubDate><guid>https://60ke.github.io/drafts/rust-macro/</guid><description>先放代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 macro_rules! say_hello { ($arg:expr) =&amp;gt; { println!(&amp;#34;{}&amp;#34;, $arg); }; } macro_rules! re_hello { ($arg:expr) =&amp;gt; { say_hello!($arg); say_hello!($arg) }; } macro_rules! many_greetings { ($times:expr) =&amp;gt; {{ for i in 0..$times { re_hello!(i); } }}; } fn main() { let a = &amp;#34;111&amp;#34;; re_hello!(a); many_greetings!(4); }</description></item><item><title>ewasm虚拟机开发</title><link>https://60ke.github.io/posts/ewasm%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BC%80%E5%8F%91/</link><pubDate>Tue, 22 Sep 2020 11:05:04 +0000</pubDate><guid>https://60ke.github.io/posts/ewasm%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BC%80%E5%8F%91/</guid><description>准备 解析wasm字节码 wasm概览 wasm指令集 wasm类型 wasm包含12种section: 每个section包括: section id(大小1字节) section size(格式为u32记录section大小) data(section中保存的内容,格式取决于section id) 每个 section 都是可选的, 如果某个 wasm 模</description></item><item><title>rust闭包</title><link>https://60ke.github.io/drafts/rust%E9%97%AD%E5%8C%85/</link><pubDate>Fri, 18 Sep 2020 14:15:42 +0000</pubDate><guid>https://60ke.github.io/drafts/rust%E9%97%AD%E5%8C%85/</guid><description>概念 “闭包（closure）是一种匿名函数,具有“捕获”外部变量的能力。闭包有时候也被称作lambda表达式。它有两个特点：（1）可以像函数一样被调用；（2）可以捕获当前环境中的变量。” 摘录来自: 范长春. “深入浅出Rust。” 闭包与函数的显著区别是闭包可以补货变量。 code is cheap,show code: 1 2 3</description></item><item><title>rust笔记</title><link>https://60ke.github.io/drafts/rust%E7%AC%94%E8%AE%B0/</link><pubDate>Fri, 18 Sep 2020 14:13:44 +0000</pubDate><guid>https://60ke.github.io/drafts/rust%E7%AC%94%E8%AE%B0/</guid><description>10进制转换为16进制并输出 1 assert_eq!(format!(&amp;#34;{:x}&amp;#34;, 42), &amp;#34;2a&amp;#34;); 根据value从列表中获取对应的index （How do I find the index of an element in an array, vector or slice?） 1 2 3 4 5 fn main() { let test = vec![&amp;#34;one&amp;#34;, &amp;#34;two&amp;#34;, &amp;#34;three&amp;#34;]; let index = test.iter().position(|&amp;amp;r| r == &amp;#34;two&amp;#34;).unwrap(); println!(&amp;#34;{}&amp;#34;, index); } rust int与string的转换 1 2 3 4 let my_string = &amp;#34;27&amp;#34;.to_string(); // `parse()` works with `&amp;amp;str` and `String`! let my_int = my_string.parse::&amp;lt;i32&amp;gt;().unwrap(); let my_int: i32 = my_string.parse().unwrap(); rust 合并list实例 1 2 3 4 5 6</description></item><item><title>rust测试</title><link>https://60ke.github.io/drafts/rust%E6%B5%8B%E8%AF%95/</link><pubDate>Wed, 09 Sep 2020 10:40:25 +0000</pubDate><guid>https://60ke.github.io/drafts/rust%E6%B5%8B%E8%AF%95/</guid><description>println! in rust test 参考：Why doesn&amp;rsquo;t println! work in Rust unit tests? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 use std::fs::File; use std::path::Path; use std::io::prelude::*; fn read_file(path: &amp;amp;Path) { let mut file = File::open(path).unwrap(); let mut contents = String::new(); file.read_to_string(&amp;amp;mut contents).unwrap(); println!(&amp;#34;{}&amp;#34;, contents); } #[test] fn test_read_file() { let path = &amp;amp;Path::new(&amp;#34;/etc/hosts&amp;#34;); println!(&amp;#34;{:?}&amp;#34;, path); read_file(path); } rustc --test main.rs; ./main ./main --nocapture cargo test -- --nocapture</description></item><item><title>Enclave开发</title><link>https://60ke.github.io/posts/Enclave%E5%BC%80%E5%8F%91/</link><pubDate>Fri, 17 Jan 2020 16:58:55 +0000</pubDate><guid>https://60ke.github.io/posts/Enclave%E5%BC%80%E5%8F%91/</guid><description>Enclave开发包括以下几个步骤： 使用EDL文件定义不可信app和encalve(飞地)之间的接口(由ecall和ocall来实现) 实现app和encalve函数。 编译app和enclave。编译中,Edger8r生成可信和不可信的代理/桥函数,enclave签名工具生成enc</description></item><item><title>sgx开发</title><link>https://60ke.github.io/posts/sgx/</link><pubDate>Fri, 17 Jan 2020 16:46:35 +0000</pubDate><guid>https://60ke.github.io/posts/sgx/</guid><description>sgx 开发 当前项目依赖： incubator-teaclave-sgx-sdk 1.0.9(原baidu rust sgx sdk) Rust nightly-2019-08-01 https://github.com/enigmampc/enigma-core 的一些crate(后续开发剔除) 适用于rust sgx的crate： https://github.com/dingelish/sgx-world 项目开发遇到的问题 evm读写集的记录： 在sputnikvm的返回结果上添加读写集。可对比 https://github.com/60ke/sputnikvm 与 https://github.com/enigmampc/sputnikvm/tree/enigma-next 的区别 ocall： 传入address和storage的key</description></item><item><title>rust宏展开</title><link>https://60ke.github.io/drafts/rust%E5%AE%8F%E5%B1%95%E5%BC%80/</link><pubDate>Thu, 10 Oct 2019 11:18:04 +0000</pubDate><guid>https://60ke.github.io/drafts/rust%E5%AE%8F%E5%B1%95%E5%BC%80/</guid><description>2019年10月10日11:22:15 cargo-expand包可对rust进行宏展开,但是这个特性是基于rust的nightly版本的,所以我们首先需要安装nightly版本的rust： Run rustup install nightly 安装cargo-expand: cargo install cargo-expand 运行： rustup run nightly cargo rustc -- -Z unstable-options --pretty=expanded 对指定rust文件进行展</description></item><item><title>rust学习02</title><link>https://60ke.github.io/drafts/rust%E5%AD%A6%E4%B9%A002/</link><pubDate>Wed, 19 Jun 2019 09:50:21 +0000</pubDate><guid>https://60ke.github.io/drafts/rust%E5%AD%A6%E4%B9%A002/</guid><description>cargo 安装指定版本： 1 cargo install --version 2.0.13 racer 新建 vector 为了创建一个新的空 vector,可以调用 Vec::new 函数,如示例 8-1 所示： 1 let v: Vec&amp;lt;i32&amp;gt; = Vec::new(); 示例 8-1：新建一个空的 vector 来储存 i32 类型的值 注意这里我们增加了一个类型注解。因为没有向这个 vector 中插入任何值,Rust 并不知道我们想要储存什么类型的元素。这是一个非常重要的点。v</description></item><item><title>rust学习01</title><link>https://60ke.github.io/drafts/rust%E5%AD%A6%E4%B9%A001/</link><pubDate>Thu, 06 Jun 2019 15:24:14 +0000</pubDate><guid>https://60ke.github.io/drafts/rust%E5%AD%A6%E4%B9%A001/</guid><description>rust在线中文教程：https://kaisery.github.io/trpl-zh-cn rust猜数字游戏： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 use std::io; use std::cmp::Ordering; use rand::Rng; use std::time::Duration; use std::thread::sleep; fn main(){ println!(&amp;#34;Guess the number!&amp;#34;); let secret_number = rand::thread_rng().gen_range(1,101); // println!(&amp;#34;The secret number is :{}&amp;#34;,secret_number); loop { println!(&amp;#34;Please input your guess&amp;#34;); let mut guess = String::new(); io::stdin().read_line(&amp;amp;mut guess).expect(&amp;#34;Failed to read line&amp;#34;); let guess: u32 = match guess.trim().parse(){ Ok(num) =&amp;gt;</description></item></channel></rss>