<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>并发 on LookForAdmin的博客</title><link>https://60ke.github.io/tags/%E5%B9%B6%E5%8F%91/</link><description>Recent content in 并发 on LookForAdmin的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 26 Oct 2021 16:18:24 +0000</lastBuildDate><atom:link href="https://60ke.github.io/tags/%E5%B9%B6%E5%8F%91/index.xml" rel="self" type="application/rss+xml"/><item><title>go并发map</title><link>https://60ke.github.io/drafts/go%E5%B9%B6%E5%8F%91map/</link><pubDate>Tue, 26 Oct 2021 16:18:24 +0000</pubDate><guid>https://60ke.github.io/drafts/go%E5%B9%B6%E5%8F%91map/</guid><description>golang默认map不是并发安全的 (Why are map operations not defined to be atomic?)[https://golang.org/doc/faq#atomic_maps] After long discussion it was decided that the typical use of maps did not require safe access from multiple goroutines, and in those cases where it did, the map was probably part of some larger data structure or computation that was already synchronized. Therefore requiring that all map operations grab a mutex would slow down most programs and add safety to few. This was not an easy decision, however, since it means uncontrolled map access can crash the program. The language does not preclude atomic map updates. When required, such as when hosting an untrusted program, the implementation could interlock map access. Map access is unsafe only when updates are occurring. As long</description></item></channel></rss>