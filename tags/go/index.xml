<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>go on LookForAdmin的博客</title><link>https://60ke.github.io/tags/go/</link><description>Recent content in go on LookForAdmin的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 29 Mar 2022 10:23:34 +0000</lastBuildDate><atom:link href="https://60ke.github.io/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>go泛型实践</title><link>https://60ke.github.io/posts/go%E6%B3%9B%E5%9E%8B%E5%AE%9E%E8%B7%B5/</link><pubDate>Tue, 29 Mar 2022 10:23:34 +0000</pubDate><guid>https://60ke.github.io/posts/go%E6%B3%9B%E5%9E%8B%E5%AE%9E%E8%B7%B5/</guid><description>之前go在1.18 dev版本中支持了泛型,当时大致的看了一下,但是考虑到是dev版本可能功能并没有完全确定,所以并没有进行练习。今天更新到go1.18 darwin/arm64发现可以直接用泛型了,写篇文章记下笔记。 泛型程序设计（generic programming）是程序设计语言</description></item><item><title>go并发map</title><link>https://60ke.github.io/drafts/go%E5%B9%B6%E5%8F%91map/</link><pubDate>Tue, 26 Oct 2021 16:18:24 +0000</pubDate><guid>https://60ke.github.io/drafts/go%E5%B9%B6%E5%8F%91map/</guid><description>golang默认map不是并发安全的 (Why are map operations not defined to be atomic?)[https://golang.org/doc/faq#atomic_maps] After long discussion it was decided that the typical use of maps did not require safe access from multiple goroutines, and in those cases where it did, the map was probably part of some larger data structure or computation that was already synchronized. Therefore requiring that all map operations grab a mutex would slow down most programs and add safety to few. This was not an easy decision, however, since it means uncontrolled map access can crash the program. The language does not preclude atomic map updates. When required, such as when hosting an untrusted program, the implementation could interlock map access. Map access is unsafe only when updates are occurring. As long</description></item><item><title>数据结构之子字符串查找</title><link>https://60ke.github.io/drafts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE/</link><pubDate>Fri, 16 Apr 2021 16:48:01 +0000</pubDate><guid>https://60ke.github.io/drafts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE/</guid><description>实现一个查找 substring 的函数。如果在母串中找到了子串,返回子串在母串中出现的下标,如果没有找到,返回 -1,如果子串是空串,则返回 0 。 go语言可以用strings直接实现 1 2 3 4 import &amp;#34;strings&amp;#34; func strStr(haystack string, needle string) int { return strings.Index(haystack, needle) } strings中的index是Rabin–Karp算法实现的 实现同样的功能的算法还有 s</description></item><item><title>go调用RUST</title><link>https://60ke.github.io/drafts/go%E8%B0%83%E7%94%A8RUST/</link><pubDate>Tue, 06 Apr 2021 10:46:59 +0000</pubDate><guid>https://60ke.github.io/drafts/go%E8%B0%83%E7%94%A8RUST/</guid><description>无参函数调用 先写一个rust的lib项目生成动态库 1 cargo new --lib embed Cargo.toml 1 2 3 4 5 6 7 8 9 10 11 12 13 [package] name = &amp;#34;embed&amp;#34; version = &amp;#34;0.1.0&amp;#34; authors = [&amp;#34;k &amp;lt;2589788697@qq.com&amp;gt;&amp;#34;] edition = &amp;#34;2018&amp;#34; # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] [lib] name = &amp;#34;embed&amp;#34; crate-type = [&amp;#34;dylib&amp;#34;] lib.rs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 use std::thread; #[no_mangle] fn process(){ let handles:Vec&amp;lt;_&amp;gt;=(0..=10).map(|_|{ thread::spawn(||{ let mut x = 0; for _ in 0..5000000{ x += 1 } x }) }).collect(); for h in handles{ println!(&amp;#34;thread finished with count={}&amp;#34;,h.join().map_err(|_|&amp;#34;could not join a thread&amp;#34;).unwrap()); } } 编译 运行 cargo build -</description></item></channel></rss>